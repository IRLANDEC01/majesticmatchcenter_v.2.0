---
description: 
globs: 
alwaysApply: true
---
# Правила для среды разработки (Codex / Cursor)

## 0. Настройка Memory Bank

1. При первом запуске автоматически создай папку `memory-bank/` в корне репозитория, если её ещё нет.  
2. Сгенерируй шесть базовых файлов-заглушек (Markdown):  
   - `projectbrief.md`  
   - `productContext.md`  
   - `systemPatterns.md`  
   - `techContext.md`  
   - `activeContext.md`  
   - `progress.md`  
3. Заполни каждый файл коротким описанием (1–2 абзаца), чтобы они не были пустыми.  
4. Все новые знания сохраняй в этих файлах; не держи важную информацию только «в голове».  
5. Убедись, что в `.cursor/rules/memory-bank.mdc` есть строка `memory-bank/`, чтобы Cursor читал папку автоматически.

---

## 1. Общие принципы работы

- Действуй как профессиональный full-stack разработчик Next.js. Пиши чистый, оптимальный и поддерживаемый код.
- Главная цель — создать надёжную, масштабируемую, легко расширяемую систему.
- Используем **TypeScript (ES2022)**, `zod` для схем и валидации, `SWR` и `React Query` для клиентского кеша.
- Перед каждой задачей читай весь `memory-bank`, особенно `systemPatterns.md` и `activeContext.md`.
- Задавай столько уточняющих вопросов, сколько нужно, чтобы исключить двусмысленность.
- Предлагай улучшения, если можешь упростить код, сделать его более безопасным или гибким.
- Все изменения фиксируй в `.cursor/rules/memory-bank.mdc` и соответствующих Markdown-файлах.
- При любом изменении экспортов — выполняй глобальный поиск по репозиторию и обновляй импорты.

---

## 2. Архитектура и паттерны (обязательные к соблюдению)

### Структура

- Соблюдай **слоистую архитектуру**: `UI → API → Domain → Infra`.
- Каждый модуль (игроки, турниры, шаблоны) выделен в отдельную feature-папку со своей логикой.
- Используем следующие паттерны:
  - `Factory` — создание сущностей и DTO
  - `Repository` — доступ к данным
  - `Domain Service` — бизнес-логика вне моделей
  - `Value Object` — обособленные типы (например, `Rating`, `DisplayName`)
  - `Schema Versioning` — контроль эволюции документов
  - `Audit Trail` — прозрачность изменений
  - `Cache Aside` + `invalidateByTag` — для Redis и Next.js кэша
  - `Event-driven sync` — для Meilisearch и фоновых задач

### Поведение и ответственность

- Каждый слой делает только свою работу. UI не знает о MongoDB, API не знает о кешах напрямую.
- API-маршруты тонкие — вызывают сервисы, не содержат бизнес-логики.
- Все сложные вычисления и правила хранятся в `domain`-слое.

---

## 3. Код-стиль и структура проекта

- Репозитории — в `src/lib/repos/**`
- Доменные функции — в `src/lib/domain/**`
- Очереди BullMQ — в `src/queues/**`
- Компоненты: PascalCase. Хуки: camelCase с префиксом `use`. Файлы и папки: kebab-case.
- UI: TailwindCSS + shadcn/ui, на TypeScript.
- Коммиты: `Conventional Commits` (`feat:`, `fix:`, `chore:`, `refactor:`)
- Не используем классы без необходимости — предпочтительно функции и композиция.

---

## 4. Работа с кешем

- Используем `getCacheAdapter()` — никакого прямого доступа к Redis.
- Все операции кэширования и инвалидации реализованы через `cacheService` или `cache-adapter`.
- Кэш на уровне Next.js (`revalidateTag`) включается вручную через `dynamic = 'force-static'`.
- SWR и React Query работают в режиме `stale-while-revalidate` в UI.

---

## 5. Поиск (Meilisearch)

- Все документы индексируются через `search-service.ts`, а не напрямую.
- При изменении данных добавляется задача в очередь `searchQueue` (`update-index`, `delete-index`).
- Для подготовки search-документа используется `buildSearchEntry(entity)`, логика изолирована.
- Настраиваются `filterableAttributes`, `sortableAttributes`, `searchableAttributes`.
- Универсальный API-эндпоинт: `/api/search?q=...&entities=players,families`, с форматом:

```json
{
  "data": {
    "query": "Иван",
    "results": {
      "players": [...],
      "families": [...]
    }
  }
}
```

---

## 6. Тестирование

- Пишем тесты на `Vitest + Testing Library`
- Среда: `happy-dom`, покрытие: `@vitest/coverage-v8`
- Используем `Builder pattern` в тестах (`playerBuilder().withRating(100).build()`)
- Моки через `vi.mock`, Redis — через `ioredis-mock`
- Интеграционные тесты изолированы: база данных очищается перед каждым запуском
- `vitest.setup.ts` содержит: очистку Mongo, подключение `.env.test`, инициализацию моки

---

## 7. Процесс «Plan → Act»

### Plan Mode
1. Прочитать весь `memory-bank`.
2. Задать уточняющие вопросы.
3. Составить пошаговый план и дождаться подтверждения.

### Act Mode
1. Обновить код, тесты и документы.
2. Сообщить о каждом завершённом шаге.
3. Зафиксировать изменения в `memory-bank`.

---

## 8. Обновление Memory Bank

Фиксируем изменения, когда:
- Появляется новая переменная окружения
- Добавляется новый паттерн/архитектурное решение
- Изменяется инфраструктура (Docker, CI/CD)
- Завершён значимый этап (релиз, миграция, редизайн)

---

## 9. Чек-лист перед PR

- ✅ Код на **TypeScript**, без `any` (если только не осознанно)
- ✅ Архитектура и слои не нарушены
- ✅ Все Redis-операции идут через адаптер
- ✅ В `.env.example` и `.env.production.sample` добавлены переменные
- ✅ Добавлен/обновлён соответствующий раздел в `memory-bank/`
- ✅ Тесты на **Vitest** написаны или обновлены
- ✅ Покрытие кода не упало (если актуально)
- ✅ Коммит подписан как `feat`, `fix`, `refactor` и т.п.