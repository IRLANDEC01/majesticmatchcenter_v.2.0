---
description: 
globs: 
alwaysApply: true
---
# Правила для среды разработки (Codex / Cursor)

## 0. Настройка **Memory Bank**
1. **При первом запуске** автоматически создай папку `memory-bank/` в корне репозитория, если её ещё нет.  
2. Сгенерируй шесть базовых файлов-заглушек (Markdown):  
   `projectbrief.md`, `productContext.md`, `systemPatterns.md`,  
   `techContext.md`, `activeContext.md`, `progress.md`.  
3. Заполни каждый файл коротким описанием (1–2 абзаца), чтобы они не были пустыми.  
4. Все новые знания сохраняй в этих файлах; не держи важную информацию только «в голове».  
5. Убедись, что в `.cursor/rules/memory-bank.mdc` есть строка `memory-bank/`, чтобы Cursor читал папку автоматически.

## 1. Общие принципы работы
* **Действуй как профессиональный full-stack разработчик Next.js.** Пиши чистый, оптимальный и поддерживаемый код.
* **Главная цель — создать максимально надёжный и масштабируемый проект** в соответствии с архитектурой.
* Всегда пишем только на **JavaScript ES2022**. TypeScript не используем.
* Перед каждой задачей полностью читаем все файлы Memory Bank.
* После получения задачи задаём столько уточняющих вопросов, сколько нужно, чтобы точно понять цель, результат и ограничения.
* Предлагаем улучшения, если видим более эффективное решение.
* Любые важные открытия или изменения фиксируем в `.cursor/rules/memory-bank.mdc` и соответствующих файлах в `memory-bank/`.
* При любом рефакторинге модуля, который меняет его экспорт, мой следующий шаг — это не запуск тестов, а глобальный поиск по всей кодовой базе, чтобы найти и исправить каждый import этого модуля.

## 2. Код-стиль и структура проекта
* Соблюдаем слоистую архитектуру: **UI → API → Domain → Infra**.
* Новые доменные функции — в `src/lib/domain/**`; репозитории — в `src/lib/repos/**`.
* Для кэша используем только `getCacheAdapter()`; прямой импорт Redis запрещён.
* Очереди — BullMQ. Каждый тип задачи — отдельный файл в `src/queues/`.
* По возможности используем фабричные функции вместо классов, чтобы упростить тесты.
* Имена директорий и файлов — **kebab-case**. Компоненты — PascalCase. Хуки — camelCase c префиксом `use`.
* UI: Tailwind + shadcn/ui, без TypeScript.
* Коммиты следуют Conventional Commits (`feat:`, `fix:`, `docs:`, `refactor:`).
* Тесты — Jest + Testing Library; Redis мокается `ioredis-mock`.

## 3. Процесс «Plan → Act»
### Plan Mode
1. Прочитать всю Memory Bank.  
2. Задать  уточняющие вопросы.  
3. Составить пошаговый план и дождаться утверждения.

### Act Mode
1. Обновить нужные файлы кода и документации.  
2. После каждого шага сообщить, что сделано и что дальше.  
3. По завершении зафиксировать новые сведения в Memory Bank.

## 4. Обновление Memory Bank
Фиксируем изменения, когда  
* появляется новая переменная окружения;  
* меняется архитектурный паттерн;  
* обнаружено ограничение среды (RAM, версия Node, порты);  
* завершён значимый этап (релиз, миграция, деплой).

## 5. Проверочный чек-лист перед PR
* Код без TypeScript.  
* Слоистая архитектура не нарушена.  
* Все Redis-операции идут через адаптер.  
* В `.env.example` и `.env.production.sample` добавлены новые переменные.  
* В `progress.md` отражено, что сделано и что осталось.


---