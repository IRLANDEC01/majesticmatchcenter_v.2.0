---
description: 
globs: 
alwaysApply: true
---
# Правила для среды разработки (Codex / Cursor)

## 0. Настройка Memory Bank

1. При первом запуске автоматически создай папку `memory-bank/` в корне репозитория, если её ещё нет.  
2. Сгенерируй шесть базовых файлов-заглушек (Markdown):  
   - `projectbrief.md`  
   - `productContext.md`  
   - `systemPatterns.md`  
   - `techContext.md`  
   - `activeContext.md`  
   - `progress.md`  
3. Заполни каждый файл коротким описанием (1–2 абзаца), чтобы они не были пустыми.  
4. Все новые знания сохраняй в этих файлах; не держи важную информацию только «в голове».  
5. Убедись, что в `.cursor/rules/memory-bank.mdc` есть строка `memory-bank/`, чтобы Cursor читал папку автоматически.

---

## 1. Общие принципы работы

- Действуй как профессиональный full-stack разработчик Next.js. Пиши чистый, оптимальный и поддерживаемый код.
- Главная цель — создать максимально надёжный и масштабируемый проект в соответствии с архитектурой.
- Используем **TypeScript** (ES2022), строгое типизирование, `zod` для валидации.
- Перед каждой задачей полностью читаем все файлы Memory Bank.
- После получения задачи задаём столько уточняющих вопросов, сколько нужно, чтобы точно понять цель, результат и ограничения.
- Предлагаем улучшения, если видим более эффективное решение.
- Любые важные открытия или изменения фиксируем в `.cursor/rules/memory-bank.mdc` и соответствующих файлах в `memory-bank/`.
- При любом рефакторинге модуля, который меняет его экспорт, следующий шаг — глобальный поиск по коду, чтобы найти и обновить каждый `import`.

---

## 2. Код-стиль и структура проекта

- Соблюдаем слоистую архитектуру: **UI → API → Domain → Infra**.
- Новые доменные функции — в `src/lib/domain/**`; репозитории — в `src/lib/repos/**`.
- Для кэша используем только `getCacheAdapter()`; прямой импорт Redis запрещён.
- Очереди — BullMQ. Каждый тип задачи — отдельный файл в `src/queues/`.
- По возможности используем фабричные функции вместо классов, чтобы упростить тесты.
- Имена директорий и файлов — `kebab-case`. Компоненты — PascalCase. Хуки — camelCase с префиксом `use`.
- UI: TailwindCSS + shadcn/ui, написан на TypeScript.
- Коммиты следуют Conventional Commits (`feat:`, `fix:`, `docs:`, `refactor:`).
- Тесты — **Vitest + Testing Library**:
  - Используем `happy-dom` для React-компонентов.
  - Моки Redis реализуются через `ioredis-mock`.
  - Покрытие собирается через `@vitest/coverage-v8`.

---

## 3. Процесс «Plan → Act»

### Plan Mode

1. Прочитать всю Memory Bank.  
2. Задать уточняющие вопросы.  
3. Составить пошаговый план и дождаться утверждения.

### Act Mode

1. Обновить нужные файлы кода и документации.  
2. После каждого шага сообщить, что сделано и что дальше.  
3. По завершении зафиксировать новые сведения в Memory Bank.

---

## 4. Обновление Memory Bank

Фиксируем изменения, когда:  
- появляется новая переменная окружения;  
- меняется архитектурный паттерн;  
- обнаружено ограничение среды (RAM, версия Node, порты);  
- завершён значимый этап (релиз, миграция, деплой).

---

## 5. Проверочный чек-лист перед PR

- ✅ Код написан на **TypeScript**
- ✅ Слоистая архитектура не нарушена
- ✅ Все Redis-операции идут через адаптер
- ✅ В `.env.example` и `.env.production.sample` добавлены новые переменные
- ✅ В `progress.md` отражено, что сделано и что осталось
- ✅ Тесты написаны с использованием **Vitest**
- ✅ Моки (`vi.mock`) используются корректно
- ✅ Проверено покрытие кода (если актуально)
