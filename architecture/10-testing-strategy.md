# Стратегия тестирования: Прагматичный Тестовый Трофей v2.2 (TypeScript + Vitest)

Этот документ описывает обновленный подход к тестированию, выработанный после масштабного рефакторинга и миграции на TypeScript и Vitest. Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Золотой Стандарт v2.2: Самодостаточные интеграционные тесты API

Это наш основной и самый важный вид тестов, покрывающий ~90% всех тестовых сценариев. Он основан на трех ключевых принципах: **изоляция**, **реализм** и **простота**.

### 1. Жизненный цикл тестового файла

Каждый тестовый файл (`*.test.ts`) должен быть полностью автономным и управлять своим собственным жизненным циклом подключения к базе данных.

*   **`beforeAll`**: Устанавливает соединение с тестовой базой данных с помощью `connectToTestDB()`.
*   **`afterEach`**: **Очищает** базу данных (`clearTestDB()`) и сбрасывает все моки (`vi.clearAllMocks()`) после **каждого** теста (`it`-блока). Это гарантирует, что тесты не влияют друг на друга.
*   **`afterAll`**: Закрывает соединение с базой данных (`disconnectFromTestDB()`) после выполнения всех тестов в файле.

### 2. Принцип "Без моков для внутреннего API"

Мы **никогда** не мокируем наши собственные сервисы или репозитории. Тест должен проверять всю вертикаль: `API Route` -> `Service` -> `Repo` -> `DB`. Мокировать разрешено **только** внешние зависимости (например, `next/cache`, сторонние SDK).

### 3. Паттерн "Прагматичный мост для NextRequest"

Для имитации HTTP-запроса мы используем стандартный Web API `new Request(...)`. Поскольку обработчики Next.js ожидают специфичный тип `NextRequest`, мы используем приведение типа `req as any` при вызове обработчика. Это осознанный технический компромисс, позволяющий использовать стандартный API и избежать хрупких сторонних библиотек вроде `node-mocks-http`.

### Эталонный пример (`map-templates/[id]/route.test.ts`)

```typescript
// 1. Импорты: Vitest, обработчики, хелперы для БД и тестовых данных.
import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { GET, PATCH } from './route';
import {
  connectToTestDB,
  clearTestDB,
  disconnectFromTestDB,
  createTestMapTemplate,
} from '@/lib/test-helpers';
import { revalidatePath } from 'next/cache';
import { HydratedDocument } from 'mongoose';
import { IMapTemplate } from '@/models/map/MapTemplate';

// 2. Мокируем ТОЛЬКО внешние зависимости.
vi.mock('next/cache');

describe('/api/admin/map-templates/[id]', () => {
  let activeTemplate: HydratedDocument<IMapTemplate>;

  // 3. Управляем жизненным циклом БД.
  beforeAll(async () => {
    await connectToTestDB();
  });

  // 4. Готовим данные для КАЖДОГО теста изолированно и очищаем моки.
  beforeEach(async () => {
    await clearTestDB(); // Критически важно для изоляции!
    vi.clearAllMocks();
    activeTemplate = await createTestMapTemplate({ name: 'Active Map' });
  });

  // 5. Закрываем соединение после всех тестов.
  afterAll(async () => {
    await disconnectFromTestDB();
  });

  it('должен успешно возвращать шаблон по ID', async () => {
    // Arrange: Создаем запрос, используя стандартный Web API.
    const req = new Request(`http://localhost/api/admin/map-templates/${activeTemplate.id}`);

    // Act: Вызываем обработчик, используя "прагматичный мост".
    const response = await GET(req as any, { params: { id: activeTemplate.id } });
    const body = await response.json();

    // Assert: Проверяем результат.
    expect(response.status).toBe(200);
    expect(body.data.name).toBe('Active Map');
  });

  // ... другие тесты ...
});
```

---

## Другие уровни тестирования

### Модульные (Unit) тесты — Для исключений (5% тестов)
*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики (например, сложные математические расчеты, уникальные алгоритмы), которую сложно проверить через API.
*   **ЗАПРЕЩЕНО:** Писать юнит-тесты для простых CRUD-методов.

### E2E (End-to-End) тесты — Для критических путей (5% тестов)
*   **Что это?** Тесты, имитирующие действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев.

### Статический анализ (Static Analysis)
*   `ESLint` и `TypeScript Compiler (tsc)` — наша первая линия обороны, отлавливающая ошибки на лету.

---

## Анти-паттерны v2.2: Чему мы научились

### 1. ❌ Глобальное подключение к БД в `vitest.setup.mjs`
*   **Проблема:** Попытка управлять подключением к БД в глобальном файле настройки.
*   **Почему это плохо:** Vitest может запускать тестовые файлы в разных изолированных средах (воркерах), которые не имеют доступа к состоянию, созданному в `vitest.setup.mjs`. Это приводило к ошибкам `MongoNotConnectedError`.
*   **Решение:** **Полный отказ** от логики подключения к БД в `vitest.setup.mjs`. Каждый тестовый файл должен быть **полностью самодостаточным** и управлять своим подключением через `beforeAll`/`afterAll`, как описано в "Золотом стандарте".

### 2. ❌ Использование `node-mocks-http`
*   **Проблема:** Использование сторонней библиотеки для мокирования объектов `req`/`res`.
*   **Почему это плохо:** Библиотека не полностью совместима с `NextRequest`, что приводило к ошибкам (`req.json is not a function`) и требовало "костылей" (`req as any`).
*   **Решение:** Использовать нативный `new Request()` — он является веб-стандартом и полностью поддерживается.

### 3. ❌ Мокирование внутреннего API
*   **Проблема:** Попытка мокировать сервисный или репозиторный слой в тестах API.
*   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком.
*   **Решение:** Использовать полноценные интеграционные тесты с реальной тестовой БД.

### 4. ❌ Неконсистентность в сервисах
*   **Проблема:** Изобретение "велосипедов" внутри сервиса для задачи, которая уже решена в другом методе этого же сервиса.
*   **Почему это плохо:** Приводит к дублированию логики и ошибкам.
*   **Решение:** Стремиться к максимальному переиспользованию кода внутри сервиса.

## Заключение

Новая стратегия, основанная на **самодостаточных интеграционных тестах**, делает наш тестовый набор значительно более надежным, читаемым и простым в поддержке. Этот стандарт является обязательным для всей новой и рефакторимой кодовой базы. 