# Стратегия тестирования: Тестовый Трофей

Этот документ описывает подход к тестированию в проекте, основанный на принципах «Тестового Трофея» (Testing Trophy). Главная цель — писать тесты, которые дают максимальную уверенность в работоспособности приложения при минимальных затратах на их поддержку.

## Философия

Мы не стремимся к 100% покрытию кода. Вместо этого мы фокусируемся на тестах, которые имитируют реальное использование системы и проверяют интеграцию ее частей.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Уровни тестирования

1.  **Интеграционные тесты API (Integration Tests) — Основной фокус**
    *   **Что это?** Тесты, которые отправляют реальные HTTP-запросы к нашим API-маршрутам (`/api/.../route.js`) и проверяют ответ, включая статус-код и тело ответа. Они работают с реальной (но тестовой) базой данных.
    *   **Почему они важны?** Это самый ценный вид тестов. Они проверяют, что все слои приложения (маршрутизатор, сервисы, репозитории, модели, база данных) корректно работают вместе. Успешное прохождение этих тестов дает высокую уверенность в том, что фича работает.
    *   **Инструменты:** `Jest`, `supertest` (или нативные `Request`/`Response`).

2.  **Модульные тесты (Unit Tests) — Для изолированной логики**
    *   **Что это?** Тесты, которые проверяют отдельные функции или модули (например, репозиторий или сервис) в полной изоляции от остальной системы.
    *   **Когда использовать?** Для сложной бизнес-логики, алгоритмов или утилит, которые можно и нужно проверить отдельно. Мы также покрываем юнит-тестами модели и репозитории.
    *   **Инструменты:** `Jest`.

3.  **Статический анализ (Static Analysis) — Наш линтер**
    *   **Что это?** Автоматическая проверка кода на наличие синтаксических ошибок, опечаток и несоответствий код-стайлу.
    *   **Инструменты:** `ESLint`. Он отлавливает ошибки еще на этапе написания кода.

4.  **E2E (End-to-End) тесты — Для критических путей**
    *   **Что это?** Тесты, которые полностью имитируют действия пользователя в браузере.
    *   **Когда использовать?** Очень редко, только для самых критических сценариев (например, процесс регистрации и авторизации). Эти тесты хрупкие и дорогие в поддержке.
    *   **Инструменты:** `Playwright`.

---

## Практическая реализация и правила

#### 1. Изоляция тестовой среды

Для обеспечения стабильности и независимости тестов мы используем многоуровневую изоляцию:

*   **Изоляция между файлами (на уровне воркеров Jest):**
    *   Используется пресет `@shelf/jest-mongodb`.
    *   В файле `src/lib/db.js` настроено создание **уникальной базы данных для каждого воркера Jest** путем добавления суффикса `_${process.env.JEST_WORKER_ID}` к имени БД. Это гарантирует, что параллельно запущенные тестовые файлы не влияют друг на друга.

*   **Изоляция внутри одного файла (между тестами `it`):**
    *   В глобальном файле `jest.setup.js` настроен хук `beforeEach`.
    *   Перед каждым тестом (`it`) он **полностью очищает все коллекции** в текущей базе данных с помощью `deleteMany({})`. Это гарантирует, что каждый тест начинается с чистого состояния.

#### 2. Работа с уникальными индексами

Тесты, проверяющие уникальность полей (например, создание пользователя с уже существующим email), требуют, чтобы уникальные индексы в базе данных были построены до начала теста.

*   **Правило:** В `describe`-блок любого тестового файла, который прямо или косвенно проверяет логику уникальности, **необходимо** добавлять хук `beforeAll`:
    ```javascript
    import MyModel from '@/models/MyModel';

    describe('Тестирование уникальности', () => {
      beforeAll(async () => {
        // Гарантирует, что уникальные индексы для MyModel будут созданы
        await MyModel.init();
      });

      it('не должен создавать дубликат', async () => {
        // ...
      });
    });
    ```
    Это обеспечивает стабильность таких тестов и предотвращает ложноположительные результаты.

#### 3. Структура тестовых файлов

*   Тесты должны находиться рядом с кодом, который они тестируют, в файле с суффиксом `.test.js`.
    *   `src/lib/domain/my-service.js` -> `src/lib/domain/my-service.test.js`
    *   `src/app/api/my-route/route.js` -> `src/app/api/my-route/route.test.js`

#### 4. Запуск тестов

*   **Все тесты:**
    ```bash
    npm test
    ```
*   **Один файл:**
    ```bash
    npx jest path/to/your.test.js
    ```
*   **Тесты для динамических маршрутов Next.js:**
    *   **Проблема:** Jest может не находить файлы, в пути которых есть скобки `[` и `]`, например, `src/app/api/admin/tournaments/[id]/route.test.js`.
    *   **Решение:** Использовать флаг `--runTestsByPath`, который корректно обрабатывает такие пути.
    ```bash
    npx jest --runTestsByPath path/to/your/[id]/route.test.js
    ```
*   **Тесты в режиме отладки (последовательно):**
    ```bash
    npx jest --runInBand
    ```
---

## Анти-паттерны (Чему мы научились)

Этот раздел документирует подходы, которые мы пробовали и которые привели к проблемам. Мы записываем их, чтобы не повторять ошибок.

1.  **Наивное создание уникальных данных во время выполнения:**
    *   **Проблема:** Попытка добавлять `nanoid()` к тестовым данным, чтобы избежать конфликтов в базе.
    *   **Почему это плохо:** Это не решает проблему гонки состояний. Тесты все равно могут мешать друг другу. Кроме того, это усложняет код тестов и может скрыть реальные ошибки.
    *   **Решение:** Полная изоляция баз данных для каждого воркера.

2.  **Глобальная очистка через `dropDatabase()` в `beforeEach`:**
    *   **Проблема:** Попытка удалять всю базу данных перед каждым тестом.
    *   **Почему это плохо:** Это слишком "тяжелая" операция. Она удаляет не только данные, но и индексы, что приводит к сложным гонкам состояний между процессом создания индексов и выполнением самого теста.
    *   **Решение:** Использовать более "мягкую" очистку коллекций (`deleteMany({})`), которая не затрагивает индексы. 