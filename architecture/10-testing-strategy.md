# Стратегия тестирования: Тестовый Трофей

Этот документ описывает подход к тестированию в проекте, основанный на принципах «Тестового Трофея» (Testing Trophy). Главная цель — писать тесты, которые дают максимальную уверенность в работоспособности приложения при минимальных затратах на их поддержку.

## Философия

Мы не стремимся к 100% покрытию кода. Вместо этого мы фокусируемся на тестах, которые имитируют реальное использование системы и проверяют интеграцию ее частей.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Уровни тестирования

1.  **Интеграционные тесты API (Integration Tests) — Основной фокус**
    *   **Что это?** Тесты, которые отправляют реальные HTTP-запросы к нашим API-маршрутам (`/api/.../route.js`) и проверяют ответ, включая статус-код и тело ответа. Они работают с реальной (но тестовой) базой данных.
    *   **Почему они важны?** Это самый ценный вид тестов. Они проверяют, что все слои приложения (маршрутизатор, сервисы, репозитории, модели, база данных) корректно работают вместе. Успешное прохождение этих тестов дает высокую уверенность в том, что фича работает.
    *   **Инструменты:** `Jest`, `supertest` (или нативные `Request`/`Response`).

2.  **Модульные тесты (Unit Tests) — Для изолированной логики**
    *   **Что это?** Тесты, которые проверяют отдельные функции или модули (например, репозиторий или сервис) в полной изоляции от остальной системы.
    *   **Когда использовать?** Для сложной бизнес-логики, алгоритмов или утилит, которые можно и нужно проверить отдельно. Мы также покрываем юнит-тестами модели и репозитории.
    *   **Инструменты:** `Jest`.

3.  **Статический анализ (Static Analysis) — Наш линтер**
    *   **Что это?** Автоматическая проверка кода на наличие синтаксических ошибок, опечаток и несоответствий код-стайлу.
    *   **Инструменты:** `ESLint`. Он отлавливает ошибки еще на этапе написания кода.

4.  **E2E (End-to-End) тесты — Для критических путей**
    *   **Что это?** Тесты, которые полностью имитируют действия пользователя в браузере.
    *   **Когда использовать?** Очень редко, только для самых критических сценариев (например, процесс регистрации и авторизации). Эти тесты хрупкие и дорогие в поддержке.
    *   **Инструменты:** `Playwright`.

---

## Практическая реализация и правила

#### 1. Изоляция тестовой среды

Для обеспечения стабильности и независимости тестов мы используем многоуровневую изоляцию:

*   **Изоляция между файлами (на уровне воркеров Jest):**
    *   Используется пресет `@shelf/jest-mongodb`.
    *   В файле `src/lib/db.js` настроено создание **уникальной базы данных для каждого воркера Jest** путем добавления суффикса `_${process.env.JEST_WORKER_ID}` к имени БД. Это гарантирует, что параллельно запущенные тестовые файлы не влияют друг на друга.

*   **Изоляция внутри одного файла (между тестами `it`):**
    *   В глобальном файле `jest.setup.js` настроен хук `beforeEach`.
    *   Перед каждым тестом (`it`) он **полностью очищает все коллекции** в текущей базе данных с помощью `deleteMany({})`. Это гарантирует, что каждый тест начинается с чистого состояния.

*   **Изоляция кэша (Cache):**
    *   **Проблема:** По умолчанию система пытается использовать Redis для кэширования, что требует запущенного Docker-контейнера и переменных окружения, делая тесты зависимыми от внешней инфраструктуры.
    *   **Решение:** Для полной изоляции и скорости тесты должны использовать in-memory кэш. Это достигается установкой переменной окружения `CACHE_DRIVER=memory` перед запуском тестов.
    *   **Реализация:** В `package.json` используется пакет `cross-env` для кросс-платформенной установки этой переменной:
        ```json
        "scripts": {
          "test": "cross-env CACHE_DRIVER=memory jest"
        }
        ```

#### 2. Работа с уникальными индексами

Тесты, проверяющие уникальность полей (например, создание пользователя с уже существующим email), требуют, чтобы уникальные индексы в базе данных были построены до начала теста.

*   **Правило:** В `describe`-блок любого тестового файла, который прямо или косвенно проверяет логику уникальности, **необходимо** добавлять хук `beforeAll`:
    ```javascript
    import MyModel from '@/models/MyModel';

    describe('Тестирование уникальности', () => {
      beforeAll(async () => {
        // Гарантирует, что уникальные индексы для MyModel будут созданы
        await MyModel.init();
      });

      it('не должен создавать дубликат', async () => {
        // ...
      });
    });
    ```
    Это обеспечивает стабильность таких тестов и предотвращает ложноположительные результаты.

#### 3. Структура тестовых файлов

*   Тесты должны находиться рядом с кодом, который они тестируют, в файле с суффиксом `.test.js`.
    *   `src/lib/domain/my-service.js` -> `src/lib/domain/my-service.test.js`
    *   `src/app/api/my-route/route.js` -> `src/app/api/my-route/route.test.js`

#### 4. Запуск тестов

*   **Все тесты:**
    ```bash
    npm test
    ```
*   **Один файл:**
    ```bash
    npx jest path/to/your.test.js
    ```
*   **Тесты для динамических маршрутов Next.js:**
    *   **Проблема:** Jest может не находить файлы, в пути которых есть скобки `[` и `]`, например, `src/app/api/admin/tournaments/[id]/route.test.js`.
    *   **Решение:** Использовать флаг `--runTestsByPath`, который корректно обрабатывает такие пути.
    ```bash
    npx jest --runTestsByPath path/to/your/[id]/route.test.js
    ```
*   **Тесты в режиме отладки (последовательно):**
    ```bash
    npx jest --runInBand
    ```

#### 5. Тестирование API-маршрутов (Route Handlers)

После рефакторинга и выделения логики в сервисы и репозитории, подход к тестированию API-маршрутов изменился, чтобы повысить скорость и точность тестов.

*   **Принцип:** Тест API-маршрута **не должен** быть сквозным (E2E) тестом, проверяющим всю цепочку до базы данных. Его главная задача — проверить "клей", то есть код самого обработчика.
*   **Реализация:**
    *   Слой доменных сервисов (`tournament-service`, `family-service` и т.д.) **полностью мокается** (`jest.mock(...)`).
    *   Тест проверяет, что обработчик маршрута:
        1.  Корректно извлекает данные из HTTP-запроса (параметры, тело, заголовки).
        2.  Вызывает правильный метод сервиса с правильными аргументами.
        3.  Корректно обрабатывает результат, возвращенный из мока сервиса (например, отдает `200 OK` при успехе или `404 Not Found` если сервис вернул `null`).
*   **Преимущества:**
    *   **Скорость:** Тесты выполняются мгновенно, так как нет обращений к диску или сети (БД).
    *   **Надежность:** Тесты не падают из-за ошибок в слоях ниже (сервис, репозиторий), которые уже покрыты собственными тестами.
    *   **Точность:** Если тест упал, проблема гарантированно находится в коде `route.js`, что упрощает отладку.
*   **Важно:** Полноценное интеграционное тестирование с реальной БД проводится на уровне **репозиториев** (`*-repo.test.js`). Именно эти тесты проверяют корректность Mongoose-запросов и схем.

---

## Анти-паттерны (Чему мы научились)

Этот раздел документирует подходы, которые мы пробовали и которые привели к проблемам. Мы записываем их, чтобы не повторять ошибок.

1.  **Наивное создание уникальных данных во время выполнения:**
    *   **Проблема:** Попытка добавлять `nanoid()` к тестовым данным, чтобы избежать конфликтов в базе.
    *   **Почему это плохо:** Это не решает проблему гонки состояний. Тесты все равно могут мешать друг другу. Кроме того, это усложняет код тестов и может скрыть реальные ошибки.
    *   **Решение:** Полная изоляция баз данных для каждого воркера.

2.  **Глобальная очистка через `dropDatabase()` в `beforeEach`:**
    *   **Проблема:** Попытка удалять всю базу данных перед каждым тестом.
    *   **Почему это плохо:** Это слишком "тяжелая" операция. Она удаляет не только данные, но и индексы, что приводит к сложным гонкам состояний между процессом создания индексов и выполнением самого теста.
    *   **Решение:** Использовать более "мягкую" очистку коллекций (`deleteMany({})`), которая не затрагивает индексы. 