# Стратегия тестирования: Прагматичный Тестовый Трофей v2.1 (TypeScript + Vitest)

Этот документ описывает обновленный подход к тестированию, выработанный после масштабного рефакторинга и миграции на TypeScript и Vitest. Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Золотой Стандарт: Сервисы и Репозитории как Синглтоны

**Ключевое архитектурное решение:** Все сервисы (`*-service.ts`) и репозитории (`*-repo.ts`) должны реализовываться и экспортироваться как **синглтоны (готовые экземпляры)**, а не как классы.

**Было (НЕПРАВИЛЬНО):**
```typescript
// src/lib/repos/bad-example-repo.ts
export class BadRepo { /* ... */ }

// В коде маршрута (приводило к ошибкам):
import { BadRepo } from './repo';
const repo = new BadRepo(); // Ручное создание экземпляра
```

**Стало (ПРАВИЛЬНО):**
```typescript
// src/lib/repos/good-example-repo.ts
class GoodRepo { /* ... */ }
const goodRepo = new GoodRepo(); // Экземпляр создается один раз при инициализации модуля
export default goodRepo; // Экспортируется готовый синглтон

// В коде маршрута:
import goodRepo from './repo'; // Просто импортируем и используем
```

**Почему это важно:**
1.  **Устранение ошибок:** Полностью исключает ошибки вида `TypeError: ... is not a function`, которые возникали из-за неправильной инициализации классов.
2.  **Простота:** Потребителям (API-маршрутам, другим сервисам) не нужно заботиться о создании экземпляров.
3.  **Тестируемость:** Упрощает мокирование в тестах с помощью `vi.mock`.

---

## Уровни тестирования

### 1. Интеграционные тесты API — Наш главный инструмент (90% всех тестов)

Это наш основной и самый важный вид тестов.

*   **Что это?** Тесты, которые проверяют **всю вертикаль приложения** для конкретного API-маршрута. Они имитируют HTTP-запрос, который проходит через обработчик (`route.ts`), импортированный **синглтон сервиса** и **синглтон репозитория**, выполняя реальные операции с изолированной тестовой базой данных.
*   **Где?** Располагаются рядом с файлом маршрута: `src/app/api/.../route.test.ts`.

#### **Канонический пример (стандарт v2.2 - TypeScript/Vitest):**

Этот пример иллюстрирует принцип **самодостаточных тестов** и использование полностью типизированной вертикали. Взят из рабочей вертикали `map-templates`.

```typescript
// 1. Импорты: Vitest, обработчики из route.ts, модели и хелперы.
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { GET, PATCH } from './route';
import { dbClear, createTestMapTemplate } from '@/lib/test-helpers';
import MapTemplate from '@/models/map/MapTemplate';
import { revalidatePath } from 'next/cache';

// 2. Мокируем внешние зависимости (например, Next.js Cache).
// Сервисы и репозитории НЕ мокируем!
vi.mock('next/cache', () => ({
  revalidatePath: vi.fn(),
}));

describe('API /api/admin/map-templates/[id]', () => {
  // 3. Используем beforeEach для очистки состояния между тестами.
  beforeEach(async () => {
    await dbClear(); // Очищаем БД перед каждым тестом.
    vi.mocked(revalidatePath).mockClear(); // Очищаем мок перед каждым тестом.
  });

  it('должен возвращать шаблон карты по ID', async () => {
    // Arrange: Создаем необходимые данные ПРЯМО В ТЕСТЕ.
    const template = await createTestMapTemplate({ name: 'Test Map GET' });
    const request = new Request(`http://localhost/api/admin/map-templates/${template._id}`);

    // Act: Вызываем обработчик.
    const response = await GET(request, { params: { id: template._id.toString() } });
    const body = await response.json();

    // Assert: Проверяем результат.
    expect(response.status).toBe(200);
    expect(body.name).toBe('Test Map GET');
  });

  it('должен успешно обновлять шаблон и вызывать revalidatePath', async () => {
    // Arrange
    const template = await createTestMapTemplate({ name: 'Initial Name' });
    const updateData = { name: 'Updated Name' };
    const request = new Request(`http://localhost/api/admin/map-templates/${template._id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updateData),
    });

    // Act
    const response = await PATCH(request, { params: { id: template._id.toString() } });
    const dbTemplate = await MapTemplate.findById(template._id);

    // Assert
    expect(response.status).toBe(200);
    expect(dbTemplate?.name).toBe('Updated Name');
    expect(revalidatePath).toHaveBeenCalledTimes(2);
    expect(revalidatePath).toHaveBeenCalledWith(`/admin/map-templates/${template._id.toString()}`);
  });
});
```

### 2. Модульные (Unit) тесты — Для исключений (5% тестов)

*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики (например, сложные математические расчеты, уникальные алгоритмы), которую сложно проверить через API.
*   **Пример:** `tournament-repo.test.js`, который тестирует сложный агрегационный запрос в MongoDB.
*   **ЗАПРЕЩЕНО:** Писать юнит-тесты для простых методов репозитория (`findById`, `create`) или сервисов, которые просто вызывают репозиторий. Эти сценарии полностью покрыты нашими интеграционными тестами API.

### 3. E2E (End-to-End) тесты — Для критических путей (5% тестов)

*   **Что это?** Тесты, имитирующие действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев.

### 4. Статический анализ (Static Analysis)

*   `ESLint` и `TypeScript Compiler (tsc)` — наша первая линия обороны, отлавливающая ошибки на лету.

---

## Анти-паттерны v2.0: Чему мы научились на TypeScript

### 1. ❌ Ловушка `.lean()` в репозиториях
*   **Проблема:** Использование метода `.lean()` в `find()`-методах `BaseRepo`, когда последующая логика предполагает работу с полноценным Mongoose-документом.
*   **Почему это плохо:** `.lean()` возвращает "голый" JS-объект, а не Mongoose Document. В результате теряются все методы (`.save()`, `.set()`), виртуальные поля и хуки. Это приводит к труднодиагностируемым ошибкам типизации (`Property '_id' does not exist...`) и падениям в рантайме, когда сервис пытается вызвать `.save()` у обычного объекта.
*   **Решение:** **Никогда не использовать `.lean()` в методах репозитория, предназначенных для последующего обновления данных (паттерн "Find-and-Save")**. Методы `find()` в `BaseRepo` должны возвращать `HydratedDocument<T>[]`, чтобы гарантировать наличие всей функциональности Mongoose. `.lean()` можно использовать только для read-only запросов, где данные сразу отдаются на клиент.

### 2. ❌ Неконсистентность в сервисах
*   **Проблема:** Изобретение "велосипедов" внутри сервиса для решения задачи, которая уже решена в другом методе этого же сервиса (например, вызов несуществующего `repo.findByName()` вместо использования `repo.find({ filter: ... })`).
*   **Почему это плохо:** Приводит к дублированию логики и ошибкам, которые сложно отследить.
*   **Решение:** Перед написанием новой логики в сервисе всегда проверять, нет ли уже существующего, проверенного способа для решения этой задачи в рамках этого же файла. **Стремиться к максимальному переиспользованию кода внутри сервиса.**

### 3. ❌ Устаревшие или неточные тесты
*   **Проблема:** Тесты, которые проверяют устаревшее поведение API или содержат ошибки в собственной логике подготовки данных.
*   **Почему это плохо:** Такие тесты "врут". Они либо падают на работающем коде, либо (что еще хуже) проходят на сломанном. Пример: наш тест на валидацию, который падал на этапе `Arrange`, а не на этапе `Act`, или тест на `revalidatePath`, проверявший старый URL.
*   **Решение:** Рассматривать тесты как **неотъемлемую часть фичи**. При любом изменении API необходимо с таким же вниманием обновлять и тесты, чтобы они точно отражали новое поведение. **Каждый тест должен быть атомарным и проверять ровно одну вещь.**

### 4. ❌ Мокирование внутреннего API
*   **Проблема:** Попытка мокировать сервисный или репозиторный слой в тестах API.
*   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком.
*   **Решение:** Использовать полноценные интеграционные тесты с реальной тестовой БД. Мокировать следует только **внешние** зависимости (например, `next/cache`, `redis`, сторонние SDK).

### 5. ❌ Зависимость от `populateDb` и глобального `beforeEach`
*   **Проблема:** Создание большого количества данных в глобальном хуке `beforeEach`.
*   **Почему это плохо:** Делает тесты хрупкими и неявными. Непонятно, какие именно данные нужны для конкретного теста.
*   **Решение:** **Принцип самодостаточных тестов (Self-Contained Tests).** Каждый тест (`it` блок) должен сам создавать только те данные, которые ему необходимы для работы. `beforeEach` используется только для очистки (`dbClear()`, `vi.mocked(...).mockClear()`).

### 6. ❌ Зависимость от специфичных методов репозитория в тестах
*   **Проблема:** В ходе рефакторинга мы столкнулись с ошибкой `TypeError: this.repo.findByName is not a function`. Проблема заключалась в том, что сервис вызывал специфичный метод (`findByName`), который был определен в `TournamentTemplateRepo`, но мог отсутствовать в `BaseRepo` или в моках, используемых в тестовой среде.
*   **Почему это плохо:** Это создает хрупкую связь между сервисом и конкретной реализацией репозитория, усложняя тестирование и мокирование. Тесты начинают падать не из-за ошибки в бизнес-логике, а из-за особенностей тестового окружения.
*   **Решение:** Сервисный слой должен, по возможности, использовать **универсальные, базовые методы репозитория** (например, `repo.findOne({ name: ... })`) вместо кастомных (`repo.findByName(...)`). Это делает сервис более устойчивым, а тесты — более надежными, так как они полагаются на гарантированно существующий API базового репозитория. Специфичные методы в дочерних репозиториях следует использовать только для действительно сложных, уникальных запросов к БД (например, с агрегациями).

## Заключение

Новая стратегия, основанная на **синглтонах**, **самодостаточных интеграционных тестах** и учете новых **анти-паттернов**, делает наш тестовый набор значительно более надежным, читаемым и простым в поддержке. Этот стандарт является обязательным для всей новой и рефакторимой кодовой базы. 