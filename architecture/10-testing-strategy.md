# Стратегия тестирования: Прагматичный Тестовый Трофей

Этот документ описывает подход к тестированию в проекте, основанный на принципах «Тестового Трофея» (Testing Trophy). Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Уровни тестирования: Наша реализация

### 1. Интеграционные тесты API — Золотой стандарт (90% всех тестов)

Это наш основной и самый важный вид тестов. Они дают наибольшую отдачу от вложенных усилий.

*   **Что это?** Тесты, которые проверяют **всю вертикаль приложения** для конкретного API-маршрута. Они имитируют HTTP-запрос, который проходит через обработчик (`route.js`), сервисный слой (`*-service.js`) и слой репозиториев (`*-repo.js`), выполняя **реальные операции с изолированной тестовой базой данных**.
*   **Почему?** Успешное прохождение этих тестов дает максимальную уверенность в том, что фича работает как единое целое. Они ловят ошибки на всех уровнях: от неправильной валидации до багов в логике базы данных.
*   **Где?** Располагаются рядом с файлом маршрута: `src/app/api/.../route.test.js`.

#### **Канонический пример (шаблон для новых тестов):**

```javascript
// 1. Импортируем обработчики, модель и утилиты для БД
import { POST, GET } from './route';
import MyModel from '@/models/MyModel';
import { connectToDatabase, disconnectFromDatabase } from '@/lib/db';

describe('/api/path/to/endpoint', () => {

  // 2. Управляем подключением к БД: одно на весь файл
  beforeAll(async () => {
    await connectToDatabase();
    // Гарантирует, что уникальные индексы будут созданы перед тестами
    await MyModel.init(); 
  });

  afterAll(async () => {
    await disconnectFromDatabase();
  });

  // 3. Очищаем данные ПЕРЕД КАЖДЫМ тестом для полной изоляции
  beforeEach(async () => {
    await MyModel.deleteMany({});
  });

  // 4. Группируем тесты по HTTP-методам
  describe('POST', () => {
    it('должен успешно создавать сущность и возвращать 201', async () => {
      // Arrange: готовим данные и создаем нативный объект запроса
      const requestData = { name: 'Test' };
      const request = new Request('http://localhost/api/...', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData),
      });

      // Act: вызываем обработчик маршрута напрямую
      const response = await POST(request);

      // Assert: проверяем статус и тело ответа
      expect(response.status).toBe(201);
      const body = await response.json();
      expect(body.name).toBe('Test');
      
      // (Опционально) Assert: проверяем состояние базы данных
      const dbItem = await MyModel.findById(body._id);
      expect(dbItem).not.toBeNull();
    });
  });
});
```

### 2. Модульные/изолированные тесты (Unit/Isolated Tests) — Для исключений (5% тестов)

*   **Что это?** Тесты, которые проверяют один конкретный модуль (функцию, класс) в относительной изоляции.
*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики, которую сложно или невозможно полноценно проверить через API.
*   **Хороший пример:** `tournament-repo.test.js`, который тестирует сложный агрегационный запрос в MongoDB. Проверить все граничные случаи этой агрегации через API было бы очень громоздко.
*   **Плохой пример (ЗАПРЕЩЕНО):** Писать юнит-тесты для простых методов репозитория (`findById`, `create`) или сервисов, которые просто вызывают репозиторий. Эти сценарии уже полностью покрыты нашими интеграционными тестами API.

### 3. E2E (End-to-End) тесты — Для критических путей (5% тестов)

*   **Что это?** Тесты, которые полностью имитируют действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев (например, полный цикл регистрации, оплаты и создания заказа). Эти тесты хрупкие и дорогие в поддержке.

### 4. Статический анализ (Static Analysis)

*   **Что это?** `ESLint` работает постоянно, отлавливая ошибки, опечатки и несоответствия код-стайлу еще на этапе написания кода. Это наша первая линия обороны.

---

## Анти-паттерны и наш опыт

Этот раздел документирует подходы, которые мы пробовали и которые привели к проблемам. **Так делать не нужно.**

1.  **❌ Мокирование сервисного слоя в тестах API (ГЛАВНЫЙ АНТИ-ПАТТЕРН)**
    *   **Проблема:** Попытка тестировать обработчики API (`route.js`) в изоляции, полностью мокируя доменный слой (`*-service.js`).
    *   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком. Ошибки в логике репозитория, в схеме Mongoose или в самом сервисе остаются незамеченными. Это создает ложное чувство безопасности и нарушает главный принцип "Тестового Трофея".
    *   **Решение:** Всегда использовать полноценные интеграционные тесты для API, которые работают с реальной тестовой БД. Мокирование допустимо только для действительно внешних сервисов (например, стороннее API для отправки SMS).

2.  **❌ Использование сторонних библиотек для моков запроса (например, `node-mocks-http`)**
    *   **Проблема:** Использование внешних зависимостей для создания фейковых объектов `req` и `res`, как это принято в экосистеме Express.
    *   **Почему это плохо:** Next.js App Router работает с нативными веб-стандартами `Request` и `Response`. Использование сторонних библиотек добавляет ненужную зависимость, усложняет код и может маскировать проблемы, так как создаваемые моки не полностью идентичны реальным объектам, с которыми работает Next.js.
    *   **Решение:** Всегда использовать нативный конструктор `new Request()` для создания тестовых запросов. Это просто, не требует зависимостей и на 100% соответствует среде выполнения.

3.  **❌ Наивное создание уникальных данных во время выполнения:**
    *   **Проблема:** Попытка добавлять `nanoid()` или случайные строки к тестовым данным, чтобы избежать конфликтов в базе.
    *   **Почему это плохо:** Это не решает проблему гонки состояний и не гарантирует изоляцию. Это усложняет код тестов и может скрыть реальные ошибки.
    *   **Решение:** Изоляция тестов через `beforeEach` и `deleteMany({})`.

4.  **❌ Отсутствие `MyModel.init()` в `beforeAll`**
    *   **Проблема:** Тесты, проверяющие уникальность полей (`unique: true` в схеме), могут падать или давать ложноположительные результаты, если уникальный индекс не успел построиться в MongoDB.
    *   **Решение:** Всегда вызывать `await MyModel.init()` в блоке `beforeAll` для всех моделей, которые используются в тестовом файле. Это гарантирует, что все индексы будут готовы к работе.

5.  **❌ "Осиротевшие" тестовые файлы**
    *   **Проблема:** При удалении или переименовании файла с кодом (например, `.../route.js`) его тестовый файл (`.../route.test.js`) остается в проекте. При запуске тестов это вызывает ошибку `Cannot find module './route'`, и вся тестовая сессия падает.
    *   **Решение:** Всегда удалять тестовый файл вместе с файлом, который он тестирует.

6.  **❌ Запуск тестов параллельно (по умолчанию)**
    *   **Проблема:** В некоторых средах, особенно при большом количестве тестов, работающих с базой данных, параллельный запуск (`jest` без флагов) может приводить к нестабильной работе, зависаниям и непредсказуемым ошибкам.
    *   **Решение:** Для надежного и последовательного выполнения тестов использовать флаг `--runInBand`, который заставляет Jest выполнять все тесты друг за другом в одном процессе. Пример: `npx jest --runInBand`.

7.  **❌ Проблемы с запуском `npx` в Windows PowerShell**
    *   **Проблема:** В стандартной конфигурации Windows политика безопасности PowerShell (`ExecutionPolicy`) может блокировать выполнение `npx`, что приводит к ошибке `UnauthorizedAccess`.
    *   **Решение (Workaround):** Вместо `npx jest` вызывать исполняемый файл Jest напрямую через Node.js: `node node_modules/jest/bin/jest.js --runInBand`. Это обходит ограничения PowerShell.

8.  **❌ Разбросанная логика обработки ошибок в API-маршрутах**
    *   **Проблема:** Каждый API-маршрут (`route.js`) содержит свою собственную логику `try/catch` с множеством `if/else` для определения типа ошибки по ее коду или тексту (например, `if (error.code === 11000)` для дубликатов в MongoDB).
    *   **Почему это плохо:** Это нарушает принцип DRY (Don't Repeat Yourself) и смешивает ответственности. Слой API не должен знать о внутренних кодах ошибок базы данных. Тесты, проверяющие обработку ошибок, становятся сложными, так как им нужно имитировать очень специфичные и хрупкие условия.
    *   **Решение:** Внедрение централизованной системы ошибок.
        1.  **Доменный сервис** выбрасывает семантическую ошибку (например, `throw new DuplicateError()`).
        2.  **API-маршрут** оборачивает вызов в `try/catch` и просто передает любую ошибку в единый обработчик `handleApiError(error)`.
        3.  **Единый обработчик** `handleApiError` преобразует семантическую ошибку в правильный HTTP-ответ (например, `DuplicateError` -> `409 Conflict`). Это делает код чистым, а тесты простыми: нужно лишь проверить, что API возвращает ожидаемый статус-код, не вдаваясь в детали реализации. 