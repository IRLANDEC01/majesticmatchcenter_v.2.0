# Стратегия тестирования: Прагматичный Тестовый Трофей v2.0

Этот документ описывает обновленный подход к тестированию, выработанный после масштабного рефакторинга. Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Золотой Стандарт: Сервисы и Репозитории как Синглтоны

**Ключевое архитектурное решение:** Все сервисы (`*-service.js`) и репозитории (`*-repo.js`) должны реализовываться и экспортироваться как **синглтоны (готовые экземпляры)**, а не как классы.

**Было (НЕПРАВИЛЬНО):**
```javascript
// src/lib/repos/bad-example-repo.js
export class BadRepo { /* ... */ }

// В коде маршрута (приводило к ошибкам):
import { BadRepo } from './repo';
const repo = new BadRepo(); // Ручное создание экземпляра
```

**Стало (ПРАВИЛЬНО):**
```javascript
// src/lib/repos/good-example-repo.js
class GoodRepo { /* ... */ }
const goodRepo = new GoodRepo(); // Экземпляр создается один раз при инициализации модуля
export default goodRepo; // Экспортируется готовый синглтон

// В коде маршрута:
import goodRepo from './repo'; // Просто импортируем и используем
```

**Почему это важно:**
1.  **Устранение ошибок:** Полностью исключает ошибки вида `TypeError: undefined is not a function`, которые возникали из-за неправильной инициализации классов.
2.  **Простота:** Потребителям (API-маршрутам, другим сервисам) не нужно заботиться о создании экземпляров.
3.  **Тестируемость:** Упрощает мокирование в тестах, если оно необходимо.

---

## Уровни тестирования

### 1. Интеграционные тесты API — Наш главный инструмент (90% всех тестов)

Это наш основной и самый важный вид тестов.

*   **Что это?** Тесты, которые проверяют **всю вертикаль приложения** для конкретного API-маршрута. Они имитируют HTTP-запрос, который проходит через обработчик (`route.js`), импортированный **синглтон сервиса** и **синглтон репозитория**, выполняя реальные операции с изолированной тестовой базой данных.
*   **Где?** Располагаются рядом с файлом маршрута: `src/app/api/.../route.test.js`.

#### **Канонический пример (стандарт v2.0):**

Этот пример иллюстрирует принцип **самодостаточных тестов** и использование синглтонов.

```javascript
// 1. Импорты: обработчик, модели и хелперы
import { GET, PATCH } from './route.js';
import { dbConnect, dbDisconnect, dbClear } from '@/lib/test-helpers.js';
import MapTemplate from '@/models/map/MapTemplate.js';
import { revalidatePath } from 'next/cache';

// 2. Мокируем внешние зависимости. Сервисы и репозитории НЕ мокируем!
jest.mock('next/cache', () => ({
  revalidatePath: jest.fn(),
}));

describe('GET /api/admin/map-templates/[id]', () => {
  // 3. Управляем подключением к БД
  beforeAll(dbConnect);
  afterAll(dbDisconnect);
  beforeEach(async () => {
    await dbClear(); // Очищаем БД перед каждым тестом
    revalidatePath.mockClear(); // Очищаем мок перед каждым тестом
  });

  it('должен возвращать шаблон карты по ID', async () => {
    // Arrange: Создаем необходимые данные ПРЯМО В ТЕСТЕ.
    const template = await MapTemplate.create({
      name: 'Test Map',
      description: 'A map for testing',
      isActive: true,
    });

    const request = new Request(`http://localhost/api/admin/map-templates/${template._id}`);

    // Act: Вызываем обработчик
    const response = await GET(request, { params: { id: template._id.toString() } });

    // Assert: Проверяем результат
    expect(response.status).toBe(200);
    const body = await response.json();
    expect(body.name).toBe('Test Map');
  });

  it('должен архивировать шаблон и вызывать revalidatePath', async () => {
    // Arrange
    const template = await MapTemplate.create({ name: 'Template to Archive' });
    const request = new Request(`http://localhost/api/admin/map-templates/${template._id}/archive`, {
      method: 'PATCH',
    });

    // Act
    const response = await PATCH(request, { params: { id: template._id.toString() } });
    const updatedTemplate = await MapTemplate.findById(template._id);

    // Assert
    expect(response.status).toBe(200);
    expect(updatedTemplate.archivedAt).not.toBeNull();
    expect(revalidatePath).toHaveBeenCalledWith('/admin/map-templates');
    expect(revalidatePath).toHaveBeenCalledTimes(1);
  });
});
```

### 2. Модульные (Unit) тесты — Для исключений (5% тестов)

*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики (например, сложные математические расчеты, уникальные алгоритмы), которую сложно проверить через API.
*   **Пример:** `tournament-repo.test.js`, который тестирует сложный агрегационный запрос в MongoDB.
*   **ЗАПРЕЩЕНО:** Писать юнит-тесты для простых методов репозитория (`findById`, `create`) или сервисов, которые просто вызывают репозиторий. Эти сценарии полностью покрыты нашими интеграционными тестами API.

### 3. E2E (End-to-End) тесты — Для критических путей (5% тестов)

*   **Что это?** Тесты, имитирующие действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев.

### 4. Статический анализ (Static Analysis)

*   `ESLint` — наша первая линия обороны, отлавливающая ошибки на лету.

---

## Анти-паттерны: Чему мы научились

### 1. ❌ Хаос Классов (ГЛАВНЫЙ АНТИ-ПАТТЕРН)
*   **Проблема:** Экспорт **классов** вместо **экземпляров (синглтонов)** для сервисов и репозиториев.
*   **Почему это плохо:** Приводило к постоянным ошибкам `TypeError: ... is not a function` или `Cannot read properties of undefined`. Каждый потребитель (API-маршрут) был вынужден сам создавать экземпляр (`new Service()`), что приводило к путанице, дублированию и ошибкам, когда в конструктор не передавались нужные зависимости.
*   **Решение:** **Всегда экспортировать `default` готовый экземпляр (синглтон).** Это гарантирует, что существует только один экземпляр сервиса/репозитория, и он всегда правильно сконфигурирован.

### 2. ❌ Мокирование внутреннего API
*   **Проблема:** Попытка мокировать сервисный или репозиторный слой в тестах API.
*   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком.
*   **Решение:** Использовать полноценные интеграционные тесты с реальной тестовой БД. Мокировать следует только **внешние** зависимости (например, `next/cache`, `redis`, сторонние SDK).

### 3. ❌ Зависимость от `populateDb` и `beforeEach`
*   **Проблема:** Создание большого количества данных в глобальном хуке `beforeEach` с помощью "магического" хелпера `populateDb`.
*   **Почему это плохо:** Делает тесты хрупкими и неявными. Непонятно, какие именно данные нужны для конкретного теста, а изменение в `populateDb` может сломать десятки тестов.
*   **Решение:** **Принцип самодостаточных тестов (Self-Contained Tests).** Каждый тест (`it` блок) должен сам создавать только те данные, которые ему необходимы для работы. `beforeEach` используется только для очистки (`dbClear()`, `jest.clearAllMocks()`).

### 4. ❌ Неправильная работа с `Request` и `Response`
*   **Проблема:** Использование сторонних библиотек (вроде `node-mocks-http`) для создания объектов `req`/`res`.
*   **Решение:** Всегда использовать нативные веб-стандарты: `new Request(...)` и `new Response(...)`. Это на 100% соответствует среде выполнения Next.js.

### 5. ❌ Проблемы с Jest и средой выполнения
*   **Зависание тестов:** Часто вызвано незакрытыми асинхронными операциями.
    *   **Решение:** Запускать тесты с флагом `--detectOpenHandles` для диагностики и `--runInBand` для последовательного выполнения, что повышает стабильность.
*   **Блокировка в PowerShell:**
    *   **Решение:** Использовать прямой вызов: `node node_modules/jest/bin/jest.js --runInBand`.
*   **Конфликты индексов Mongoose:**
    *   **Решение:** Не вызывать `Model.init()` в тестах. Если индексы нужны, они должны быть созданы через миграции.

### 6. ❌ Неправильная валидация Zod
*   **Проблема:** Zod по умолчанию "съедает" поля, не описанные в схеме.
*   **Решение:** Использовать `.passthrough()`, если нужно сохранить все поля, а не только валидируемые.

## Заключение

Новая стратегия, основанная на **синглтонах** и **самодостаточных тестах**, делает наш тестовый набор значительно более надежным, читаемым и простым в поддержке. Этот стандарт является обязательным для всей новой и рефакторимой кодовой базы. 