# Стратегия тестирования: Прагматичный Тестовый Трофей v2.4 (TypeScript + Vitest)

Этот документ описывает обновленный подход к тестированию, выработанный после масштабного рефакторинга и миграции на TypeScript и Vitest. Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Золотой Стандарт v2.2: Самодостаточные интеграционные тесты API

Это наш основной и самый важный вид тестов, покрывающий ~90% всех тестовых сценариев. Он основан на трех ключевых принципах: **изоляция**, **реализм** и **простота**.

### 1. Жизненный цикл тестового файла

Каждый тестовый файл (`*.test.ts`) должен быть полностью автономным и управлять своим собственным жизненным циклом подключения к базе данных.

*   **`beforeAll`**: Устанавливает соединение с тестовой базой данных с помощью `connectToTestDB()`.
*   **`beforeEach`**: **Очищает** базу данных (`clearTestDB()`) и сбрасывает все моки (`vi.clearAllMocks()`) перед **каждым** тестом (`it`-блока). Это гарантирует, что каждый тест начинается с чистого состояния.
*   **`afterAll`**: Закрывает соединение с базой данных (`disconnectFromTestDB()`) после выполнения всех тестов в файле.

### 2. Принцип "Без моков для внутреннего API"

Мы **никогда** не мокируем наши собственные сервисы или репозитории. Тест должен проверять всю вертикаль: `API Route` -> `Service` -> `Repo` -> `DB`. Мокировать разрешено **только** внешние зависимости (например, `next/cache`, сторонние SDK).

### 3. Паттерн "Селективное мокирование внешних интеграций"

**Новое (Январь 2025):** При тестировании сервисов с внешними интеграциями (Meilisearch, S3, внешние API) применяем **селективное мокирование**:

```typescript
// ✅ ПРАВИЛЬНО: Мокируем только внешние сервисы
vi.mock('@/lib/domain/search/search-service', () => ({
  default: {
    syncDocument: vi.fn().mockResolvedValue(undefined),
  }
}));

// ✅ ПРАВИЛЬНО: Мокируем Next.js кэш
vi.mock('next/cache', () => ({
  revalidateTag: vi.fn(),
}));

// ❌ НЕПРАВИЛЬНО: Мокировать собственные репозитории/сервисы
vi.mock('@/lib/repos/map-templates/map-template-repo');
```

**Принцип:** Мокируем только то, что **выходит за границы нашего приложения**.

### 4. Паттерн "Прагматичный мост для NextRequest"

Для имитации HTTP-запроса мы используем стандартный Web API `new Request(...)`. Поскольку обработчики Next.js ожидают специфичный тип `NextRequest`, мы используем приведение типа `req as any` при вызове обработчика. Это осознанный технический компромисс, позволяющий использовать стандартный API и избежать хрупких сторонних библиотек вроде `node-mocks-http`.

### Эталонный пример (`map-templates/[id]/route.test.ts`)

```typescript
// 1. Импорты: Vitest, обработчики, хелперы для БД и тестовых данных.
import { describe, it, expect, beforeAll, afterAll, afterEach, vi } from 'vitest';
import { GET, PATCH } from './route';
import {
  connectToTestDB,
  clearTestDB,
  disconnectFromTestDB,
  createTestMapTemplate,
} from '@/lib/test-helpers';
import { revalidatePath } from 'next/cache';
import { HydratedDocument } from 'mongoose';
import { IMapTemplate } from '@/models/map/MapTemplate';

// 2. Мокируем ТОЛЬКО внешние зависимости.
vi.mock('next/cache');

describe('/api/admin/map-templates/[id]', () => {
  let activeTemplate: HydratedDocument<IMapTemplate>;

  // 3. Управляем жизненным циклом БД.
  beforeAll(async () => {
    await connectToTestDB();
  });

  // 4. Готовим чистое состояние для КАЖДОГО теста.
  beforeEach(async () => {
    await clearTestDB(); // Критически важно для изоляции!
    vi.clearAllMocks();
  });

  // 5. Закрываем соединение после всех тестов.
  afterAll(async () => {
    await disconnectFromTestDB();
  });

  it('должен успешно возвращать шаблон по ID', async () => {
    // Arrange: Создаем тестовые данные внутри теста.
    const activeTemplate = await createTestMapTemplate({ name: 'Active Map' });
    const req = new Request(`http://localhost/api/admin/map-templates/${activeTemplate.id}`);

    // Act: Вызываем обработчик, используя "прагматичный мост".
    const response = await GET(req as any, { params: { id: activeTemplate.id } });
    const body = await response.json();

    // Assert: Проверяем результат.
    expect(response.status).toBe(200);
    expect(body.data.name).toBe('Active Map');
  });

  // ... другие тесты ...
});
```

---

## Другие уровни тестирования

### Модульные (Unit) тесты — Для исключений (5% тестов)
*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики (например, сложные математические расчеты, уникальные алгоритмы), которую сложно проверить через API.
*   **ЗАПРЕЩЕНО:** Писать юнит-тесты для простых CRUD-методов.

### E2E (End-to-End) тесты — Для критических путей (5% тестов)
*   **Что это?** Тесты, имитирующие действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев.

### Статический анализ (Static Analysis)
*   `ESLint` и `TypeScript Compiler (tsc)` — наша первая линия обороны, отлавливающая ошибки на лету.

---

## Тестирование React компонентов с внешними интеграциями

**Новый раздел (Январь 2025):** Рекомендации по тестированию компонентов, использующих SWR, внешние API и переиспользуемые хуки.

### Паттерн тестирования компонентов с SWR

```typescript
// EntitySearch.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { SWRConfig } from 'swr';
import { EntitySearch } from './entity-search';

// Мокируем SWR для контроля над данными
const mockSWRConfig = {
  dedupingInterval: 0,
  provider: () => new Map(),
};

describe('EntitySearch', () => {
  it('должен отображать результаты поиска', async () => {
    const mockResults = [{ id: '1', name: 'Test Map' }];
    const mockOnResults = vi.fn();

    // Мокируем fetch для SWR
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: { results: { mapTemplates: mockResults } }
      }),
    });

    render(
      <SWRConfig value={mockSWRConfig}>
        <EntitySearch
          entities="mapTemplates"
          onResults={mockOnResults}
        />
      </SWRConfig>
    );

    const input = screen.getByPlaceholderText(/поиск/i);
    fireEvent.change(input, { target: { value: 'test' } });

    await waitFor(() => {
      expect(mockOnResults).toHaveBeenCalledWith(
        mockResults,
        expect.objectContaining({ isLoading: false })
      );
    });
  });
});
```

### Паттерн тестирования хуков с внешними зависимостями

```typescript
// useSearch.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { SWRConfig } from 'swr';
import { useSearch } from './use-search';

describe('useSearch', () => {
  it('должен выполнять поиск с debounce', async () => {
    const mockFetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { results: { mapTemplates: [] } } }),
    });
    global.fetch = mockFetch;

    const { result } = renderHook(
      () => useSearch({ entities: 'mapTemplates' }),
      {
        wrapper: ({ children }) => (
          <SWRConfig value={{ provider: () => new Map() }}>
            {children}
          </SWRConfig>
        ),
      }
    );

    // Проверяем debounce
    result.current.setSearchTerm('test');
    expect(mockFetch).not.toHaveBeenCalled();

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/admin/search?q=test')
      );
    }, { timeout: 1000 });
  });
});
```

**Ключевые принципы:**
- ✅ Мокировать `fetch` для контроля над данными
- ✅ Использовать `SWRConfig` для изоляции кэша
- ✅ Тестировать debounce и асинхронное поведение
- ✅ Проверять правильность вызовов коллбеков

---

## Анти-паттерны v2.2: Чему мы научились

### 1. ❌ Глобальное подключение к БД в `vitest.setup.mjs`
*   **Проблема:** Попытка управлять подключением к БД в глобальном файле настройки.
*   **Почему это плохо:** Vitest может запускать тестовые файлы в разных изолированных средах (воркерах), которые не имеют доступа к состоянию, созданному в `vitest.setup.mjs`. Это приводило к ошибкам `MongoNotConnectedError`.
*   **Решение:** **Полный отказ** от логики подключения к БД в `vitest.setup.mjs`. Каждый тестовый файл должен быть **полностью самодостаточным** и управлять своим подключением через `beforeAll`/`afterAll`, как описано в "Золотом стандарте".

### 2. ❌ Использование `node-mocks-http`
*   **Проблема:** Использование сторонней библиотеки для мокирования объектов `req`/`res`.
*   **Почему это плохо:** Библиотека не полностью совместима с `NextRequest`, что приводило к ошибкам (`req.json is not a function`) и требовало "костылей" (`req as any`).
*   **Решение:** Использовать нативный `new Request()` — он является веб-стандартом и полностью поддерживается.

### 3. ❌ Мокирование внутреннего API
*   **Проблема:** Попытка мокировать сервисный или репозиторный слой в тестах API.
*   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком.
*   **Решение:** Использовать полноценные интеграционные тесты с реальной тестовой БД.

### 4. ❌ Неконсистентность в сервисах
*   **Проблема:** Изобретение "велосипедов" внутри сервиса для задачи, которая уже решена в другом методе этого же сервиса.
*   **Почему это плохо:** Приводит к дублированию логики и ошибкам.
*   **Решение:** Стремиться к максимальному переиспользованию кода внутри сервиса.

### 5. ❌ Тестирование реальных внешних сервисов
*   **Проблема:** Попытка тестировать интеграцию с реальным Meilisearch, S3 или другими внешними сервисами в unit/integration тестах.
*   **Почему это плохо:** 
    - Тесты становятся медленными и нестабильными
    - Зависимость от внешней инфраструктуры
    - Сложность настройки CI/CD
*   **Решение:** Мокировать внешние сервисы и тестировать только логику интеграции.

### 6. ❌ Игнорирование синхронных операций в тестах
*   **Проблема:** При добавлении синхронных вызовов внешних сервисов (например, `syncDocument`) не обновлять существующие тесты.
*   **Почему это плохо:** Тесты не покрывают новую логику и могут пропустить ошибки.
*   **Решение:** Всегда проверять, что моки внешних сервисов вызываются с правильными параметрами:
```typescript
it('должен синхронно индексировать новый шаблон', async () => {
  // ... создание шаблона
  
  expect(mockSearchService.syncDocument).toHaveBeenCalledWith(
    'update', 
    'MapTemplate', 
    expect.any(String)
  );
});
```

### 7. ❌ Отсутствие тестов для переиспользуемых компонентов
*   **Проблема:** Создание универсальных компонентов (EntitySearch, useSearch) без соответствующих тестов.
*   **Почему это плохо:** Баги в переиспользуемых компонентах влияют на множество страниц.
*   **Решение:** **Обязательное** покрытие тестами всех переиспользуемых компонентов и хуков.

### 8. ❌ API Routes без явного подключения к MongoDB
*   **Проблема:** API routes, использующие сервисы с запросами к БД, не устанавливают явное подключение к MongoDB.
*   **Почему это плохо:** В контексте Next.js API routes подключение может не быть автоматически установлено, что приводит к ошибкам `MongooseError: Operation buffering timed out after 10000ms`.
*   **Пример ошибки:** 
     ```typescript
     // ❌ НЕПРАВИЛЬНО: полагается на автоматическое подключение
     export async function POST() {
       const result = await searchService.reindexAll(); // может упасть с timeout
     }
     ```
*   **Решение:** **Всегда** явно вызывать `await connectToDatabase()` в начале API route перед операциями с БД:
     ```typescript
     // ✅ ПРАВИЛЬНО: явное подключение
     export async function POST() {
       await connectToDatabase(); // гарантируем подключение
       const result = await searchService.reindexAll();
     }
     ```
*   **Контекст:** Эта проблема была обнаружена при реализации map-templates, где CLI скрипт работал (явно вызывал `connectToDatabase()`), а API route падал с timeout.

### 9. ❌ Несинхронизированная конфигурация Meilisearch
*   **Проблема:** Изменения в конфигурации индексации (`meilisearch-config.ts`) не отражаются в API ответах из-за устаревших данных в индексе.
*   **Почему это плохо:** Новые поля (например, `mapTemplateImage`) отсутствуют в результатах поиска, даже если они есть в БД.
*   **Решение:** После изменения конфигурации Meilisearch **обязательно**:
     1. Перезапустить сервер для применения новой конфигурации
     2. Выполнить полную переиндексацию: `POST /api/admin/search/reindex`
*   **Пример:** При добавлении поля `mapTemplateImage` в `buildSearchEntry` потребовался рестарт + переиндексация для отображения картинок в таблице.

## Заключение

Новая стратегия, основанная на **самодостаточных интеграционных тестах**, делает наш тестовый набор значительно более надежным, читаемым и простым в поддержке. 

**Обновления v2.4 (Январь 2025):**
- ✅ Добавлены паттерны тестирования внешних интеграций (Meilisearch, S3)
- ✅ Рекомендации по тестированию React компонентов с SWR
- ✅ Новые анти-паттерны для современной архитектуры
- ✅ Обязательное покрытие переиспользуемых компонентов
- ✅ **КРИТИЧНО:** Паттерн явного подключения к MongoDB в API routes
- ✅ **КРИТИЧНО:** Синхронизация конфигурации Meilisearch с переиндексацией

**Приоритеты покрытия:**
1. **API Routes** (интеграционные тесты) - 90% усилий
2. **Переиспользуемые компоненты** (EntitySearch, хуки) - обязательно
3. **Сложная бизнес-логика** (unit тесты) - по необходимости
4. **Критические пути** (E2E) - минимально

Этот стандарт является обязательным для всей новой и рефакторимой кодовой базы. 