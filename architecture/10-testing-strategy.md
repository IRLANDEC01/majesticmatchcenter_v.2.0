# Стратегия тестирования: Прагматичный Тестовый Трофей

Этот документ описывает подход к тестированию в проекте, основанный на принципах «Тестового Трофея» (Testing Trophy). Главная цель — писать тесты, которые дают **максимальную уверенность** в работоспособности приложения при **минимальных затратах** на их поддержку.

Мы не стремимся к 100% покрытию кода. Мы стремимся к 100% уверенности в коде.

![Тестовый трофей](https://user-images.githubusercontent.com/1500684/158276535-9488b392-3211-4663-8a30-743423774261.png)

## Уровни тестирования: Наша реализация

### 1. Интеграционные тесты API — Золотой стандарт (90% всех тестов)

Это наш основной и самый важный вид тестов. Они дают наибольшую отдачу от вложенных усилий.

*   **Что это?** Тесты, которые проверяют **всю вертикаль приложения** для конкретного API-маршрута. Они имитируют HTTP-запрос, который проходит через обработчик (`route.js`), сервисный слой (`*-service.js`) и слой репозиториев (`*-repo.js`), выполняя **реальные операции с изолированной тестовой базой данных**.
*   **Почему?** Успешное прохождение этих тестов дает максимальную уверенность в том, что фича работает как единое целое. Они ловят ошибки на всех уровнях: от неправильной валидации до багов в логике базы данных.
*   **Где?** Располагаются рядом с файлом маршрута: `src/app/api/.../route.test.js`.

#### **Канонический пример (обновленный стандарт):**

Наш новый стандарт использует централизованный хелпер `src/lib/test-helpers.js` для управления подключением к БД и создания консистентных тестовых данных. Это делает тесты более чистыми, читаемыми и надежными.

```javascript
// 1. Импортируем обработчики, модели через index и хелперы
import { POST, GET } from './route.js';
import models from '@/models/index.js';
import { dbConnect, dbDisconnect, dbClear, populateDb } from '@/lib/test-helpers.js';

const { Family } = models;

describe('/api/path/to/endpoint', () => {
  let testData; // Переменная для хранения созданных данных

  // 2. Используем хелперы для управления БД
  beforeAll(dbConnect);
  afterAll(dbDisconnect);
  
  // 3. Перед каждым тестом очищаем БД и наполняем ее свежим набором данных
  beforeEach(async () => {
    await dbClear();
    testData = await populateDb(); // Сохраняем созданные данные
  });

  // 4. Группируем тесты по HTTP-методам
  describe('POST', () => {
    it('должен успешно создавать сущность и возвращать 201', async () => {
      // Arrange: готовим данные для новой сущности
      const requestData = { name: 'New Test Item' };
      const request = new Request('http://localhost/api/...', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData),
      });

      // Act: вызываем обработчик
      const response = await POST(request);

      // Assert: проверяем ответ
      expect(response.status).toBe(201);
      const body = await response.json();
      expect(body.name).toBe(requestData.name);
      
      // Assert: проверяем состояние БД
      const dbItem = await Family.findById(body._id);
      expect(dbItem).not.toBeNull();
    });
  });
  
  describe('GET', () => {
    it('должен возвращать сущность, созданную в populateDb', async () => {
        // Arrange: Используем данные, созданные в beforeEach
        const itemToFind = testData.familyGucci;
        const request = new Request(`http://localhost/api/.../${itemToFind._id}`);
        
        // Act
        const response = await GET(request, { params: { id: itemToFind._id.toString() } });
        
        // Assert
        expect(response.status).toBe(200);
        const body = await response.json();
        expect(body.name).toBe(itemToFind.name);
    });
  });
});
```

### 2. Модульные/изолированные тесты (Unit/Isolated Tests) — Для исключений (5% тестов)

*   **Что это?** Тесты, которые проверяют один конкретный модуль (функцию, класс) в относительной изоляции.
*   **Когда использовать? Только** для сложной, инкапсулированной бизнес-логики, которую сложно или невозможно полноценно проверить через API.
*   **Хороший пример:** `tournament-repo.test.js`, который тестирует сложный агрегационный запрос в MongoDB. Проверить все граничные случаи этой агрегации через API было бы очень громоздко.
*   **Плохой пример (ЗАПРЕЩЕНО):** Писать юнит-тесты для простых методов репозитория (`findById`, `create`) или сервисов, которые просто вызывают репозиторий. Эти сценарии уже полностью покрыты нашими интеграционными тестами API.

### 3. E2E (End-to-End) тесты — Для критических путей (5% тестов)

*   **Что это?** Тесты, которые полностью имитируют действия пользователя в браузере с помощью Playwright.
*   **Когда использовать?** Редко, только для самых критических бизнес-сценариев (например, полный цикл регистрации, оплаты и создания заказа). Эти тесты хрупкие и дорогие в поддержке.

### 4. Статический анализ (Static Analysis)

*   **Что это?** `ESLint` работает постоянно, отлавливая ошибки, опечатки и несоответствия код-стайлу еще на этапе написания кода. Это наша первая линия обороны.

---

## Анти-паттерны и наш опыт

Этот раздел документирует подходы, которые мы пробовали и которые привели к проблемам. **Так делать не нужно.**

1.  **❌ Мокирование сервисного слоя в тестах API (ГЛАВНЫЙ АНТИ-ПАТТЕРН)**
    *   **Проблема:** Попытка тестировать обработчики API (`route.js`) в изоляции, полностью мокируя доменный слой (`*-service.js`).
    *   **Почему это плохо:** Такой тест не проверяет интеграцию между слоями и **не дает уверенности**, что вся фича работает целиком. Ошибки в логике репозитория, в схеме Mongoose или в самом сервисе остаются незамеченными. Это создает ложное чувство безопасности и нарушает главный принцип "Тестового Трофея".
    *   **Решение:** Всегда использовать полноценные интеграционные тесты для API, которые работают с реальной тестовой БД. Мокирование допустимо только для действительно внешних сервисов (например, стороннее API для отправки SMS).

2.  **❌ Использование сторонних библиотек для моков запроса (например, `node-mocks-http`)**
    *   **Проблема:** Использование внешних зависимостей для создания фейковых объектов `req` и `res`, как это принято в экосистеме Express.
    *   **Почему это плохо:** Next.js App Router работает с нативными веб-стандартами `Request` и `Response`. Использование сторонних библиотек добавляет ненужную зависимость, усложняет код и может маскировать проблемы, так как создаваемые моки не полностью идентичны реальным объектам, с которыми работает Next.js.
    *   **Решение:** Всегда использовать нативный конструктор `new Request()` для создания тестовых запросов. Это просто, не требует зависимостей и на 100% соответствует среде выполнения.

3.  **❌ Наивное создание уникальных данных во время выполнения:**
    *   **Проблема:** Попытка добавлять `nanoid()` или случайные строки к тестовым данным, чтобы избежать конфликтов в базе.
    *   **Почему это плохо:** Это не решает проблему гонки состояний и не гарантирует изоляцию. Это усложняет код тестов и может скрыть реальные ошибки.
    *   **Решение:** Изоляция тестов через `beforeEach` и `deleteMany({})`.

4.  **❌ Отсутствие `MyModel.init()` в `beforeAll`**
    *   **Проблема:** Тесты, проверяющие уникальность полей (`unique: true` в схеме), могут падать или давать ложноположительные результаты, если уникальный индекс не успел построиться в MongoDB.
    *   **Решение:** Всегда вызывать `await MyModel.init()` в блоке `beforeAll` для всех моделей, которые используются в тестовом файле. Это гарантирует, что все индексы будут готовы к работе.

5.  **❌ "Осиротевшие" тестовые файлы**
    *   **Проблема:** При удалении или переименовании файла с кодом (например, `.../route.js`) его тестовый файл (`.../route.test.js`) остается в проекте. При запуске тестов это вызывает ошибку `Cannot find module './route'`, и вся тестовая сессия падает.
    *   **Решение:** Всегда удалять тестовый файл вместе с файлом, который он тестирует.

6.  **❌ Запуск тестов параллельно (по умолчанию)**
    *   **Проблема:** В некоторых средах, особенно при большом количестве тестов, работающих с базой данных, параллельный запуск (`jest` без флагов) может приводить к нестабильной работе, зависаниям и непредсказуемым ошибкам.
    *   **Решение:** Для надежного и последовательного выполнения тестов использовать флаг `--runInBand`, который заставляет Jest выполнять все тесты друг за другом в одном процессе. Пример: `npx jest --runInBand`.

7.  **❌ Неправильное управление индексами (`Model.init`) в тестах**
    *   **Проблема:** Вызов `Model.init()` внутри `beforeAll` в каждом тестовом файле может привести к трудноуловимым ошибкам `E11000 (duplicate key)`, если несколько тестовых файлов одновременно пытаются создать индексы для одной и той же модели. Это нарушает изоляцию тестов на уровне всей сессии.
    *   **Почему это плохо:** Ошибка проявляется непредсказуемо и зависит от порядка выполнения тестов, что делает отладку крайне сложной. Это создает ложное впечатление, что проблема в данных теста, хотя на самом деле проблема в его настройке.
    *   **Решение:** Убрать все вызовы `Model.init()` из индивидуальных тестовых файлов (`*.test.js`). Если создание индексов перед тестами необходимо, это должно делаться централизованно: либо через миграции, либо через глобальный файл `jest.setup.js`, который выполняется один раз перед всей тестовой сессией. В нашем случае, мы убедились, что отказ от `Model.init()` в тестах и использование `--runInBand` полностью решает проблему.

8.  **❌ Проблемы с запуском `npx` в Windows PowerShell**
    *   **Проблема:** В стандартной конфигурации Windows политика безопасности PowerShell (`ExecutionPolicy`) может блокировать выполнение `npx`, что приводит к ошибке `UnauthorizedAccess`.
    *   **Решение (Workaround):** Вместо `npx jest` вызывать исполняемый файл Jest напрямую через Node.js: `node node_modules/jest/bin/jest.js --runInBand`. Это обходит ограничения PowerShell.

9.  **❌ Разбросанная логика обработки ошибок в API-маршрутах**
    *   **Проблема:** Каждый API-маршрут (`route.js`) содержит свою собственную логику `try/catch` с множеством `if/else` для определения типа ошибки по ее коду или тексту (например, `if (error.code === 11000)` для дубликатов в MongoDB).
    *   **Почему это плохо:** Это нарушает принцип DRY (Don't Repeat Yourself) и смешивает ответственности. Слой API не должен знать о внутренних кодах ошибок базы данных. Тесты, проверяющие обработку ошибок, становятся сложными, так как им нужно имитировать очень специфичные и хрупкие условия.
    *   **Решение:** Внедрение централизованной системы ошибок.
        1.  **Доменный сервис** выбрасывает семантическую ошибку (например, `throw new DuplicateError()`).
        2.  **API-маршрут** оборачивает вызов в `try/catch` и просто передает любую ошибку в единый обработчик `handleApiError(error)`.
        3.  **Единый обработчик** `handleApiError` преобразует семантическую ошибку в правильный HTTP-ответ (например, `DuplicateError` -> `409 Conflict`). Это делает код чистым, а тесты простыми: нужно лишь проверить, что API возвращает ожидаемый статус-код, не вдаваясь в детали реализации.

10. **❌ Молчаливое "пожирание" полей валидатором Zod**
    *   **Проблема:** При передаче данных из API-маршрута в сервисный слой, который использует Zod для валидации, часть полей объекта "исчезала". Например, в `payload` для завершения карты присутствовал полный массив `playerStats`, но до сервиса статистики доходили только `playerId`, а все остальные поля (`kills`, `deaths` и т.д.) терялись.
    *   **Почему это плохо:** Это приводит к трудноуловимым ошибкам `ValidationError` на более глубоких слоях (например, при сохранении в Mongoose), так как обязательные поля оказываются `undefined`. Отладка становится крайне сложной, потому что кажется, что данные корректно отправляются из теста, но сервис их по какой-то причине не получает. Коренная причина в том, что `safeParse(data)` по умолчанию возвращает новый объект `validationResult.data`, содержащий **только те поля, которые явно описаны в схеме Zod**. Все остальные поля молча отбрасываются.
    *   **Решение:** Если схема Zod описывает только часть полей объекта, а остальные нужно пропустить "как есть", необходимо явно указать это с помощью метода `.passthrough()` на уровне объекта. Это говорит Zod, что нужно проверить описанные поля, а все остальные — включить в результирующий объект `validationResult.data` без изменений.
    
    ```javascript
    // ПРИМЕР
    const mySchema = z.object({
      id: z.string(),
      // Мы не описываем name, description и т.д.
    }).passthrough(); // <-- Ключевое решение
    
    const result = mySchema.safeParse({ id: '123', name: 'Test', description: '...' });
    // result.data теперь будет { id: '123', name: 'Test', description: '...' }
    // БЕЗ .passthrough() результат был бы просто { id: '123' }
    ``` 

## Принцип самодостаточных тестов (Self-Contained Tests)

В ходе рефакторинга был выработан ключевой принцип для написания надежных и предсказуемых интеграционных тестов для API-маршрутов:

**Каждый тест (`it` блок) должен быть полностью самодостаточным.**

Это означает:
1.  **Никакой зависимости от `beforeEach`:** Тест не должен полагаться на сложные данные, созданные в хуке `beforeEach`. Этот хук может использоваться для общих действий, таких как `dbClear()`, но не для создания специфичных для теста сущностей.
2.  **Создание данных внутри теста:** Все необходимые для теста данные (модели игроков, семей, турниров) должны создаваться непосредственно внутри `it` блока. Это делает логику теста абсолютно прозрачной.
3.  **Очистка перед созданием:** В начале теста, который требует изолированных данных, следует вызывать `dbClear()`, чтобы гарантировать отсутствие "мусора" от предыдущих запусков.

**Пример плохого теста (зависит от `beforeEach`):**
```javascript
// beforeEach
beforeEach(async () => {
  testData = await populateDb({ numFamilies: 2 }); // Создает много всего
});

it('should update a family', () => {
  const familyToUpdate = testData.families[0]; // Неявная зависимость
  // ... test logic
});
```

**Пример хорошего, самодостаточного теста:**
```javascript
it('should update a family', async () => {
  await dbClear(); // 1. Очистка
  const family = await Family.create({ name: 'Test Family' }); // 2. Создание нужных данных
  
  const request = new Request(...); // 3. Логика теста
  // ...
});
```

Этот подход предотвращает каскадные падения тестов, упрощает отладку и делает тестовый набор значительно более стабильным.

## Покрытие кода (Code Coverage)

Мы не гонимся за 100% покрытием. Наша цель — **уверенность в коде**. Мы фокусируемся на тестировании критически важных путей и бизнес-логики. Отчеты о покрытии используются как инструмент для выявления "слепых зон", а не как самоцель. 

## Ключевые принципы

1.  **Пирамида тестирования**: Основной фокус на интеграционных тестах, которые дают наибольшую уверенность. Юнит-тесты используются для сложной, изолированной логики. E2E — для критических путей.
2.  **Тестируй то, что может сломаться**: Не нужно гнаться за 100% покрытием. Важнее покрыть тестами сложную бизнес-логику, точки интеграции и ключевые API-маршруты.
3.  **Тесты как документация**: Тесты должны быть написаны чисто и понятно, чтобы служить примером использования API или функции.
4.  **Самодостаточные тесты (Self-Contained Tests)**: Каждый тестовый файл (`*.test.js`) должен быть полностью независимым. Он должен самостоятельно создавать все необходимые для его работы данные (модели игроков, семей и т.д.) в блоках `beforeEach` или непосредственно в `it`. **Использование общих, "магических" фабрик данных (таких как `populateDb`) запрещено**, так как это приводит к созданию хрупких, неявных и трудноотлаживаемых тестов. Этот подход гарантирует, что тест проверяет только то, что должен, и не зависит от внешнего, неконтролируемого состояния. 