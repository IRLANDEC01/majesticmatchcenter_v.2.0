# Стратегия кэширования

Этот документ описывает все аспекты кэширования в проекте MajesticMatchCenter. Центральным элементом стратегии является Redis, но доступ к нему всегда осуществляется через слой абстракции.

## 1. Общие принципы

### 1.1 Паттерн "Cache-Aside"

Система использует паттерн "Cache-Aside" (Ленивая загрузка). Это означает, что приложение работает по следующему алгоритму:
1.  При запросе данных приложение сначала обращается к кэшу (Redis).
2.  **Если данные в кэше найдены (cache hit)**, они немедленно возвращаются пользователю.
3.  **Если данные в кэше отсутствуют (cache miss)**, приложение обращается к основной базе данных (MongoDB), извлекает данные, сохраняет их в кэш для будущих запросов, а затем возвращает пользователю.

Этот подход обеспечивает актуальность данных без усложнения логики записи.

### 1.2 Слой абстракции кэша (Cache Abstraction Layer)

Прямое использование клиента Redis в доменных сервисах запрещено. Вместо этого, все операции с кэшем должны проходить через единый интерфейс-адаптер.

**`src/lib/cache/index.js`:**
```javascript
// Этот файл экспортирует единый инстанс кэша,
// который используется во всем приложении.
export const cache = getCacheAdapter();
```

**Интерфейс адаптера:**
```javascript
// src/lib/cache/cache-adapter.js
export class CacheAdapter {
  async get(key) { /* ... */ }
  async set(key, value, options) { /* ... */ }
  async delete(key) { /* ... */ }
  async invalidateByTag(tag) { /* ... */ }
  // ... и другие методы
}
```

## 2. Стратегия инвалидации

Правильная и своевременная инвалидация кэша — ключ к консистентности данных.

### 2.1 Инвалидация по тегам

Для сложных сценариев, когда одно изменение в базе данных должно инвалидировать несколько связанных ключей в кэше, используется **инвалидация по тегам**.

1.  **При сохранении данных** в кэш им присваиваются один или несколько тегов.
    ```javascript
    // Пример: кэширование данных турнира
    await cache.set(
      `tournament:${id}`, 
      tournamentData,
      { tags: [`tournament:${id}`, 'tournaments_list'] }
    );
    ```
2.  **При обновлении или удалении** турнира, вместо удаления одного ключа, мы инвалидируем все записи по тегу.
    ```javascript
    // Инвалидирует и страницу турнира, и список всех турниров
    await cache.invalidateByTag(`tournament:${id}`);
    ```
Это позволяет избежать ситуации, когда пользователь видит устаревшие данные в списках после редактирования отдельной записи.

### 2.2 Time-To-Live (TTL)

Для всех записей в кэше по умолчанию устанавливается TTL (время жизни). Это гарантирует, что даже если механизм инвалидации по какой-то причине не сработает, устаревшие данные автоматически удалятся из кэша через определенное время.

## 3. Паритет окружений Dev/Prod

Для избежания ошибок сериализации, которые могут проявиться только в продакшене, **в проекте принято решение использовать Redis в качестве драйвера кэша по умолчанию как для production, так и для development окружений.**

In-memory адаптер (`lru-cache`) может использоваться только в исключительных случаях или для запуска тестов, где требуется полная изоляция. Фабрика `getCacheAdapter` настроена так, чтобы в первую очередь пытаться использовать Redis, если он сконфигурирован. 