# Современные паттерны программирования в MajesticMatchCenter

> **Примечание о миграции на TypeScript:** Изначально проект был начат на JavaScript (ES2022), однако сейчас находится в процессе постепенной миграции на TypeScript для повышения надежности и качества кода. **Весь новый код должен писаться на TypeScript.** Существующий код мигрируется по мере рефакторинга. Примеры в этом документе могут быть на JS, но их следует реализовывать на TS, следуя плейбуку `06b-typescript-migration-playbook.md`.

## 1. Паттерны React и Next.js

### 1.1 React Server Components (RSC)
- **Описание**: Компоненты, рендеринг которых происходит на сервере
- **Преимущества**:
  - Уменьшение JavaScript бандла на клиенте
  - Прямой доступ к базе данных без API
  - Улучшение SEO и начальной загрузки
- **Применение**: Страницы турниров, семей, игроков, статичные компоненты

### 1.2 Server Actions
- **Описание**: Серверные функции, вызываемые из форм и обработчиков событий
- **Преимущества**:
  - Прогрессивное улучшение (работа без JavaScript)
  - Валидация на сервере
  - Оптимистичные обновления UI
- **Применение**: Формы создания/редактирования, загрузка статистики, управление рейтингом

### 1.3 Container/View/Hook
- **Описание**: Разделение компонентов на контейнеры (логика), представления (UI) и хуки (состояние)
- **Структура**:
  ```
  components/admin/map-form/
  ├── MapFormContainer.jsx    # Контейнер с логикой
  ├── components/             # View компоненты
  │   └── MapFormView.jsx     # Чистое представление
  └── hooks/                  # Логика и состояние
      └── useMapForm.js       # Хук с бизнес-логикой
  ```
- **Применение**: Сложные формы, компоненты с богатой логикой

### 1.4 Islands Architecture
- **Описание**: Статический контент с интерактивными "островками"
- **Преимущества**:
  - Минимизация гидратации
  - Улучшение Core Web Vitals
  - Приоритизация интерактивности
- **Применение**: Домашняя страница, страницы турниров, профили игроков

## 2. Паттерны данных и кэширования

### 2.1 Repository Pattern (и Service Pattern)
- **Описание**: Абстракция логики работы с данными (репозитории) и бизнес-логики (сервисы) через **синглтоны**. Этот паттерн является обязательным для всех сущностей в проекте.
- **Структура**:
  ```javascript
  // src/lib/repos/tournament-repo.js
  class TournamentRepository {
    async findById(id) { /* ... */ }
    async findActive() { /* ... */ }
    async create(data) { /* ... */ }
    // ...
  }

  // Создаем и экспортируем единственный экземпляр (синглтон)
  const tournamentRepo = new TournamentRepository();
  export default tournamentRepo;
  ```
- **Преимущества**:
  - **Надежность**: Устраняет ошибки, связанные с неправильной или множественной инициализацией.
  - **Централизация логики**: Упрощает поиск и поддержку кода.
  - **Простота использования**: Потребителям (API-маршрутам) достаточно просто импортировать готовый экземпляр.
  - **Улучшенная тестируемость**: Облегчает мокирование зависимостей.
- **Применение**: Весь доступ к данным (репозитории) и вся бизнес-логика (сервисы) инкапсулированы в синглтонах.

### 2.2 CQRS-light
- **Описание**: Разделение операций чтения и записи
- **Структура**:
  ```javascript
  // Queries (оптимизированы для чтения)
  export const getTournamentWithParticipants = async (id) => { /* ... */ }
  
  // Commands (строгая валидация для записи)
  export const createTournament = async (data) => { /* ... */ }
  ```
- **Применение**: API эндпоинты, серверные компоненты

### 2.3 Strategy Pattern
- **Описание**: Выбор стратегии в зависимости от окружения
- **Пример**:
  ```javascript
  // src/lib/cache/index.js
  const cacheAdapter = process.env.NODE_ENV === 'production'
    ? new RedisAdapter(config)
    : new MemoryAdapter();
  
  // src/lib/storage/index.js
  const storageAdapter = process.env.STORAGE_DRIVER === 's3'
    ? new S3Storage(config)
    : new LocalStorage();
  ```
- **Применение**: Хранилище файлов, кэширование, аутентификация

### 2.4 Двухслойная архитектура данных ("Сырые данные" и "Витрины")
- **Описание**: Фундаментальный паттерн для работы со статистикой и историческими данными, который разделяет данные на два логических слоя для достижения одновременно и полноты, и производительности.
- **Слой 1: "Сырые данные" (Источник Правды)**
  - **Что это**: Неизменяемые записи о каждом конкретном событии (например, `PlayerMapParticipation` - участие одного игрока на одной карте).
  - **Характеристики**: Маленькие, многочисленные, записываются один раз.
  - **Назначение**: Служат "первичной документацией" или журналом операций. Гарантируют, что у нас всегда есть первоисточник для пересчета статистики или аналитики, если бизнес-правила изменятся.
- **Слой 2: "Витрины данных" (Агрегированный кэш)**
  - **Что это**: Документы, хранящие **сумму или итог** по множеству событий (например, `PlayerStats` - общая статистика игрока за все время; `PlayerTournamentParticipation` - итоговая статистика игрока за турнир).
  - **Характеристики**: Создаются один раз на сущность (1 `PlayerStats` на 1 `Player`) и постоянно обновляются.
  - **Назначение**: Обеспечивают **мгновенное чтение** итоговых данных. Вместо того, чтобы каждый раз на лету выполнять дорогостоящую агрегацию тысяч "сырых" записей, мы делаем один быстрый запрос к уже готовой "витрине".
- **Процесс работы**:
  1. Происходит событие (карта завершена), создается запись в **Слое 1** (`PlayerMapParticipation`).
  2. В очередь (BullMQ) отправляется асинхронная задача "Обновить витрину для игрока X". API отвечает пользователю, не дожидаясь.
  3. Фоновый обработчик выполняет задачу, используя данные из Слоя 1 для атомарного обновления документа в **Слое 2** (например, через `$inc`).
- **Преимущества**:
  - **Надежность**: "Источник правды" никогда не теряется.
  - **Производительность**: Чтение итоговых данных происходит мгновенно.
  - **Масштабируемость**: Обновление "витрин" можно вынести на отдельные серверы-обработчики (workers).

## 3. Паттерны безопасности

### 3.1 Defense in Depth
- **Описание**: Многоуровневая защита приложения
- **Уровни**:
  1. **Валидация форм**: Клиентская валидация с Zod
  2. **API валидация**: Серверная валидация с Zod
  3. **Mongoose валидация**: Валидация на уровне схемы
  4. **Бизнес-правила**: Проверки в сервисах
- **Применение**: Все входные данные от пользователя

### 3.2 `ConflictError` для бизнес-правил
- **Описание**: Специализированная ошибка `ConflictError` (статус 409), которая используется в сервисном слое для предотвращения операций, нарушающих бизнес-логику или текущее состояние сущности.
- **Пример**:
  ```javascript
  // src/lib/domain/map-templates/map-template-service.js
  async archiveMapTemplate(id) {
    const template = await this.getMapTemplateById(id);

    // Проверка бизнес-правила: нельзя архивировать то, что уже в архиве.
    if (template.isArchived) {
      // Выбрасываем ошибку, которую поймет API-слой.
      throw new ConflictError('Этот шаблон уже находится в архиве.');
    }

    return this.repo.archive(id);
  }
  ```
- **Применение**: Защита от бессмысленных или вредоносных операций, таких как повторная архивация, попытка завершить уже завершенный турнир и т.д. Является ключевой частью паттерна "Defense in Depth".

### 3.3 EditGuard Pattern
- **Описание**: Защита от случайных изменений критических данных
- **Пример**:
  ```javascript
  const editGuard = useEditGuard({
    type: 'tournament',
    status: tournament.status,
    allowedStatuses: ['planned', 'active']
  });
  
  // Блокировка редактирования завершенных турниров
  if (editGuard.isBlocked) {
    return <SecurityBlockMessage {...editGuard} />;
  }
  ```
- **Применение**: Формы редактирования турниров, карт, семей

### 3.4 Rate Limiting
- **Описание**: Ограничение частоты запросов к API
- **Реализация**:
  ```javascript
  // src/lib/rate-limiter.js с использованием Redis
  export const rateLimiter = createRateLimiter({
    store: new RedisStore({
      client: redisClient,
      prefix: 'ratelimit'
    }),
    windowMs: 15 * 60 * 1000, // 15 минут
    max: 100 // Лимит запросов
  });
  ```
- **Применение**: Аутентификация, критические API эндпоинты
- **Конфигурация**:
  - В production используется Redis-бэкенд для распределенного rate limiting
  - В dev/test среде можно использовать memory-store для упрощения разработки
  - Настраивается через переменную окружения `RATE_LIMIT_STORE=redis|memory`

### 3.5 Image Scanning (Trivy)
- **Описание**: Автоматическое сканирование Docker-образов на уязвимости
- **Реализация**: Запускается в CI-пайплайне для проверки всех образов
- **Преимущества**:
  - Обнаружение уязвимостей в зависимостях
  - Проверка соответствия лучшим практикам безопасности
  - Блокирование деплоя при критических уязвимостях
- **Применение**: CI/CD процесс, проверка перед деплоем

## 4. Паттерны интеграции

### 4.1 Adapter Pattern
- **Описание**: Адаптеры для внешних сервисов
- **Структура**:
  ```javascript
  // src/lib/storage/s3-adapter.js
  export class S3Adapter implements StorageAdapter {
    async upload(file) { /* ... */ }
    async download(path) { /* ... */ }
    async delete(path) { /* ... */ }
  }
  ```
- **Применение**: Хранилище файлов, кэширование, внешние API

### 4.2 Publisher-Subscriber (Redis PubSub)
- **Описание**: Асинхронная коммуникация через Redis PubSub
- **Реализация**:
  ```javascript
  // Публикация события
  await redisClient.publish('tournament:completed', JSON.stringify({
    id: tournament.id,
    name: tournament.name
  }));
  
  // Подписка на события
  redisClient.subscribe('tournament:completed');
  redisClient.on('message', (channel, message) => {
    if (channel === 'tournament:completed') {
      const data = JSON.parse(message);
      // Обработка события
    }
  });
  ```
- **Применение**: Уведомления, обновление кэша, фоновые задачи

### 4.3 Circuit Breaker
- **Описание**: Защита от каскадных сбоев внешних сервисов
- **Реализация**:
  ```javascript
  const breaker = new CircuitBreaker(
    async () => await s3Client.upload(file),
    {
      failureThreshold: 3,
      resetTimeout: 30000
    }
  );
  
  try {
    const result = await breaker.fire();
    return result;
  } catch (error) {
    // Fallback логика
    return await localStorageBackup.upload(file);
  }
  ```
- **Применение**: Интеграции с S3, внешними API, Redis 

### 4.4 Scheduled Jobs с BullMQ
- **Описание**: Планирование и выполнение фоновых задач с гарантированной доставкой
- **Преимущества**:
  - Персистентность задач в Redis
  - Атомарные операции с блокировками
  - Автоматические повторы при сбоях
  - Горизонтальное масштабирование
- **Структура**:
  - **Очереди** - раздельные очереди для разных типов задач
  - **Планировщики** - управление повторяющимися задачами
  - **Обработчики** - логика выполнения задач
  - **Мониторинг** - отслеживание выполнения через Bull Board
- **Применение**:
  - Автоматическая активация турниров и карт по расписанию
  - Периодическая очистка временных данных
  - Генерация отчетов и агрегация статистики 

**Пример структуры для формы создания/редактирования:**
```
├── components/
│   └── admin/
│       └── map-form/
│           ├── components/     # Презентационные компоненты
│           │   ├── MapFormBasicFields.jsx
│           │   ├── MapFormParticipants.jsx
│           │   └── MapFormStatistics.jsx
│           ├── hooks/          # Хуки с логикой
│           │   ├── useMapForm.js
│           │   └── useParticipants.js
│           ├── utils/          # Утилиты
│           │   └── mapFormHelpers.js
│           ├── MapFormContainer.jsx  # Контейнер с состоянием
│           └── MapFormView.jsx       # Презентационный компонент
``` 

## 5. Валидация на границе API (API Boundary Validation)

Для обеспечения надежности и предсказуемости API, вся валидация входящих данных происходит на самом внешнем уровне — в **API Route Handlers**.

*   **Инструмент**: `Zod`.
*   **Централизация**: Все Zod-схемы для конкретной сущности (например, `Player`) должны находиться в одном файле: `src/lib/api/schemas/{entity}/{entity-name}-schemas.js`.
*   **Принцип "Fail Fast"**: Запрос, не прошедший валидацию, немедленно отклоняется с ошибкой `400 Bad Request` и подробным описанием, какие поля неверны. Он никогда не достигает Domain-слоя.
*   **Единая обработка ошибок**: Все ошибки (включая ошибки валидации) в `try...catch` блоках маршрутов передаются в единый обработчик `handleApiError`, который формирует стандартизированный ответ.
*   **GET-запросы**: Валидация применяется не только к `POST`/`PUT` телам запроса, но и к query-параметрам `GET`-запросов для обеспечения полной целостности.

Этот паттерн защищает бизнес-логику от "грязных" данных и делает API строго типизированным и самодокументируемым. 