# Современные паттерны программирования в MajesticMatchCenter

> **Примечание о миграции на TypeScript:** Изначально проект был начат на JavaScript (ES2022), однако сейчас находится в процессе постепенной миграции на TypeScript для повышения надежности и качества кода. **Весь новый код должен писаться на TypeScript.** Существующий код мигрируется по мере рефакторинга. Примеры в этом документе могут быть на JS, но их следует реализовывать на TS, следуя плейбуку `06b-typescript-migration-playbook.md`.

## 1. Паттерны React и Next.js

### 1.1 React Server Components (RSC)
- **Описание**: Компоненты, рендеринг которых происходит на сервере
- **Преимущества**:
  - Уменьшение JavaScript бандла на клиенте
  - Прямой доступ к базе данных без API
  - Улучшение SEO и начальной загрузки
- **Применение**: Страницы турниров, семей, игроков, статичные компоненты

### 1.2 Server Actions
- **Описание**: Серверные функции, вызываемые из форм и обработчиков событий
- **Преимущества**:
  - Прогрессивное улучшение (работа без JavaScript)
  - Валидация на сервере
  - Оптимистичные обновления UI
- **Применение**: Формы создания/редактирования, загрузка статистики, управление рейтингом

### 1.3 Container/View/Hook
- **Описание**: Разделение компонентов на контейнеры (логика), представления (UI) и хуки (состояние)
- **Структура**:
  ```
  components/admin/map-form/
  ├── MapFormContainer.jsx    # Контейнер с логикой
  ├── components/             # View компоненты
  │   └── MapFormView.jsx     # Чистое представление
  └── hooks/                  # Логика и состояние
      └── useMapForm.js       # Хук с бизнес-логикой
  ```
- **Применение**: Сложные формы, компоненты с богатой логикой

### 1.4 Islands Architecture
- **Описание**: Статический контент с интерактивными "островками"
- **Преимущества**:
  - Минимизация гидратации
  - Улучшение Core Web Vitals
  - Приоритизация интерактивности
- **Применение**: Домашняя страница, страницы турниров, профили игроков

## 2. Паттерны данных и кэширования

### 2.1 Repository Pattern и Service Pattern (Синглтоны)
- **Описание**: Абстракция логики работы с данными (репозитории) и бизнес-логики (сервисы) через **синглтоны**. Этот паттерн является **обязательным** для всех сущностей в проекте.
- **Структура**:
  ```typescript
  // src/lib/repos/tournament-template-repo.ts
  import TournamentTemplate from '@/models/tournament/TournamentTemplate';
  import BaseRepo from './base-repo';

  class TournamentTemplateRepository extends BaseRepo<ITournamentTemplate> {
    constructor() {
      super(TournamentTemplate, 'tournament-template');
    }
    // ... кастомные методы репозитория
  }

  // Создаем и экспортируем единственный экземпляр (синглтон)
  const tournamentTemplateRepo = new TournamentTemplateRepository();
  export default tournamentTemplateRepo;
  ```
- **Преимущества**:
  - **Надежность**: Устраняет ошибки, связанные с неправильной или множественной инициализацией.
  - **Централизация логики**: Упрощает поиск и поддержку кода.
  - **Простота использования**: Потребителям (API-маршрутам) достаточно просто импортировать готовый экземпляр.
  - **Улучшенная тестируемость**: Облегчает мокирование в тестах с помощью `vi.mock`.
- **Применение**: Весь доступ к данным (репозитории) и вся бизнес-логика (сервисы) инкапсулированы в синглтонах.
- **Улучшение (Июль 2024)**: Для повышения гибкости и упрощения тестирования, метод `find` в `BaseRepo` был переработан. Вместо булева флага `includeArchived` он теперь принимает строковый параметр `status: 'active' | 'archived' | 'all'`, что позволяет более декларативно запрашивать данные и покрывает все сценарии выборки.

### 2.2 Паттерн обновления "Find-and-Save"
- **Описание**: "Золотой стандарт" для операций обновления данных, когда требуется максимальная надежность и запуск полного конвейера Mongoose.
- **Процесс**:
  1. Документ находится в базе данных с помощью `repo.findById(id)`.
  2. В сервисе применяются необходимые изменения к полям документа: `doc.name = data.name;`.
  3. Вызывается метод `doc.save()`.
- **Преимущества**:
  - **Полная валидация**: Гарантированно запускает все валидаторы, определенные в Mongoose-схеме.
  - **Запуск хуков**: Гарантированно запускает все `pre` и `post` хуки (например, для генерации `slug`).
  - **Надежность**: В отличие от `findOneAndUpdate`, этот паттерн обеспечивает атомарность на уровне приложения и позволяет выполнять сложную бизнес-логику перед сохранением.
- **Когда использовать**: **Всегда**, кроме случаев массового обновления, где производительность критичнее надежности. Этот паттерн является предпочтительным для всех `PATCH` / `PUT` операций в API.
- **Анти-паттерн**: Использование `repo.update()` (`findByIdAndUpdate`) для одиночных обновлений. Этот метод **не запускает** хуки схемы и по умолчанию **не запускает** валидаторы, что может привести к сохранению некорректных данных.

### 2.3 CQRS-light
- **Описание**: Разделение операций чтения и записи
- **Структура**:
  ```javascript
  // Queries (оптимизированы для чтения)
  export const getTournamentWithParticipants = async (id) => { /* ... */ }
  
  // Commands (строгая валидация для записи)
  export const createTournament = async (data) => { /* ... */ }
  ```
- **Применение**: API эндпоинты, серверные компоненты

### 2.4 Strategy Pattern
- **Описание**: Выбор стратегии в зависимости от окружения
- **Пример**:
  ```javascript
  // src/lib/cache/index.js
  const cacheAdapter = process.env.NODE_ENV === 'production'
    ? new RedisAdapter(config)
    : new MemoryAdapter();
  
  // src/lib/storage/index.js
  const storageAdapter = process.env.STORAGE_DRIVER === 's3'
    ? new S3Storage(config)
    : new LocalStorage();
  ```
- **Применение**: Хранилище файлов, кэширование, аутентификация

### 2.5 Двухслойная архитектура данных ("Сырые данные" и "Витрины")
- **Описание**: Фундаментальный паттерн для работы со статистикой и историческими данными, который разделяет данные на два логических слоя для достижения одновременно и полноты, и производительности.
- **Слой 1: "Сырые данные" (Источник Правды)**
  - **Что это**: Неизменяемые записи о каждом конкретном событии (например, `PlayerMapParticipation` - участие одного игрока на одной карте).
  - **Характеристики**: Маленькие, многочисленные, записываются один раз.
  - **Назначение**: Служат "первичной документацией" или журналом операций. Гарантируют, что у нас всегда есть первоисточник для пересчета статистики или аналитики, если бизнес-правила изменятся.
- **Слой 2: "Витрины данных" (Агрегированный кэш)**
  - **Что это**: Документы, хранящие **сумму или итог** по множеству событий (например, `PlayerStats` - общая статистика игрока за все время; `PlayerTournamentParticipation` - итоговая статистика игрока за турнир).
  - **Характеристики**: Создаются один раз на сущность (1 `PlayerStats` на 1 `Player`) и постоянно обновляются.
  - **Назначение**: Обеспечивают **мгновенное чтение** итоговых данных. Вместо того, чтобы каждый раз на лету выполнять дорогостоящую агрегацию тысяч "сырых" записей, мы делаем один быстрый запрос к уже готовой "витрине".
- **Процесс работы**:
  1. Происходит событие (карта завершена), создается запись в **Слое 1** (`PlayerMapParticipation`).
  2. В очередь (BullMQ) отправляется асинхронная задача "Обновить витрину для игрока X". API отвечает пользователю, не дожидаясь.
  3. Фоновый обработчик выполняет задачу, используя данные из Слоя 1 для атомарного обновления документа в **Слое 2** (например, через `$inc`).
- **Преимущества**:
  - **Надежность**: "Источник правды" никогда не теряется.
  - **Производительность**: Чтение итоговых данных происходит мгновенно.
  - **Масштабируемость**: Обновление "витрин" можно вынести на отдельные серверы-обработчики (workers).

### 2.6. Паттерн "Явное именование индексов"
- **Описание**: Критически важный паттерн для предотвращения трудноуловимых ошибок на уровне базы данных, таких как `MongoServerError: E11000 duplicate key error` при конфликте имен индексов.
- **Проблема**: Если в схеме Mongoose для одного поля или набора полей создается несколько индексов (например, один для быстрого поиска, а второй — частично-уникальный для активных записей), MongoDB может сгенерировать для них одинаковые имена по умолчанию (например, `slug_1`), что приводит к ошибке при старте приложения или во время миграций.
- **Решение**: **Всегда** явно задавать уникальное имя для **каждого** индекса через опцию `name`.
- **Пример**:
  ```typescript
  // src/models/tournament/TournamentTemplate.ts
  tournamentTemplateSchema.index(
    { name: 1 },
    {
      name: 'name_unique_active', // <-- Уникальное имя
      unique: true,
      partialFilterExpression: { archivedAt: { $eq: null } },
    },
  );
  tournamentTemplateSchema.index(
    { slug: 1 },
    {
      name: 'slug_unique_active', // <-- Уникальное имя
      unique: true,
      partialFilterExpression: { archivedAt: { $eq: null } },
    },
  );
  ```
- **Преимущества**:
  - **100% надежность**: Полностью исключает конфликты имен.
  - **Читаемость**: Имена индексов становятся самодокументируемыми (`slug_unique_active` гораздо понятнее, чем `slug_1`).
  - **Управляемость**: Упрощает администрирование индексов (удаление, перестроение) на уровне БД.

### 2.7. Паттерн "Согласование жизненного цикла: `pre('save')` и валидаторы"
- **Описание**: Паттерн для корректной работы с полями, которые генерируются автоматически перед сохранением документа.
- **Проблема**: В Mongoose валидаторы (`required`, `minlength` и т.д.) запускаются **до** хуков `pre('save')`. Если поле (например, `slug`) помечено как `required: true`, но его значение генерируется из другого поля (`name`) только внутри `pre('save')`, то при создании нового документа валидация провалится, так как на момент проверки поле `slug` будет еще пустым.
- **Решение**: **Не использовать** валидатор `required: true` для полей, генерируемых в хуках.
  - **Обоснование**: Обязательность такого поля гарантируется логикой самого хука (он всегда его создаст, если исходное поле, например `name`, присутствует и валидно). А уникальность обеспечивается не валидатором, а соответствующим **уникальным индексом** в базе данных, что гораздо надежнее.
- **Пример**:
  ```typescript
  // НЕПРАВИЛЬНО:
  slug: {
    type: String,
    required: true, // <-- Это вызовет ошибку валидации при создании
    unique: true,
  }
  
  // ПРАВИЛЬНО:
  slug: {
    type: String, // <-- required убран
    lowercase: true,
    trim: true,
  },
  // ... а уникальность гарантируется отдельным индексом
  tournamentTemplateSchema.index(
    { slug: 1 },
    { name: 'slug_unique_active', unique: true, ... }
  );
  ```

## 3. Паттерны безопасности

### 3.1 Defense in Depth (Защита в глубину)
- **Описание**: Многоуровневая защита приложения.
- **Уровни**:
  1. **Валидация форм**: Клиентская валидация с Zod.
  2. **API валидация**: Серверная валидация с Zod в `route.ts`. **Это первая и главная линия обороны.**
  3. **Mongoose валидация**: Валидация на уровне схемы при вызове `.save()`.
  4. **Бизнес-правила**: Проверки в сервисах (например, `throw new ConflictError(...)`).
  5. **Валидация на уровне репозитория**: Защита от невалидных запросов к БД.
- **Практический пример**: В ходе рефакторинга шаблонов турниров именно валидация Zod (Уровень 2) первой поймала ошибку в данных, не позволив им дойти до сервисного слоя (Уровень 4), что подтвердило эффективность данного подхода.
- **Пример для Уровня 5**: В `BaseRepo` все методы (`findById`, `update` и т.д.), принимающие `id`, обязаны сначала проверить его валидность с помощью `mongoose.Types.ObjectId.isValid(id)`. Это предотвращает бессмысленные запросы к базе данных с заведомо некорректными идентификаторами, реализуя принцип "Fail Fast" на самом низком уровне доступа к данным.

### 3.2 `ConflictError` для бизнес-правил
- **Описание**: Специализированная ошибка `ConflictError` (статус 409), которая используется в сервисном слое для предотвращения операций, нарушающих бизнес-логику или текущее состояние сущности.
- **Пример**:
  ```javascript
  // src/lib/domain/map-templates/map-template-service.js
  async archiveMapTemplate(id) {
    const template = await this.getMapTemplateById(id);

    // Проверка бизнес-правила: нельзя архивировать то, что уже в архиве.
    if (template.isArchived) {
      // Выбрасываем ошибку, которую поймет API-слой.
      throw new ConflictError('Этот шаблон уже находится в архиве.');
    }

    return this.repo.archive(id);
  }
  ```
- **Применение**: Защита от бессмысленных или вредоносных операций, таких как повторная архивация, попытка завершить уже завершенный турнир и т.д. Является ключевой частью паттерна "Defense in Depth".

### 3.3 EditGuard Pattern
- **Описание**: Защита от случайных изменений критических данных
- **Пример**:
  ```javascript
  const editGuard = useEditGuard({
    type: 'tournament',
    status: tournament.status,
    allowedStatuses: ['planned', 'active']
  });
  
  // Блокировка редактирования завершенных турниров
  if (editGuard.isBlocked) {
    return <SecurityBlockMessage {...editGuard} />;
  }
  ```
- **Применение**: Формы редактирования турниров, карт, семей

### 3.4 Rate Limiting
- **Описание**: Ограничение частоты запросов к API
- **Реализация**:
  ```javascript
  // src/lib/rate-limiter.js с использованием Redis
  export const rateLimiter = createRateLimiter({
    store: new RedisStore({
      client: redisClient,
      prefix: 'ratelimit'
    }),
    windowMs: 15 * 60 * 1000, // 15 минут
    max: 100 // Лимит запросов
  });
  ```
- **Применение**: Аутентификация, критические API эндпоинты
- **Конфигурация**:
  - В production используется Redis-бэкенд для распределенного rate limiting
  - В dev/test среде можно использовать memory-store для упрощения разработки
  - Настраивается через переменную окружения `RATE_LIMIT_STORE=redis|memory`

### 3.5 Image Scanning (Trivy)
- **Описание**: Автоматическое сканирование Docker-образов на уязвимости
- **Реализация**: Запускается в CI-пайплайне для проверки всех образов
- **Преимущества**:
  - Обнаружение уязвимостей в зависимостях
  - Проверка соответствия лучшим практикам безопасности
  - Блокирование деплоя при критических уязвимостях
- **Применение**: CI/CD процесс, проверка перед деплоем

## 4. Паттерны интеграции

### 4.1 Adapter Pattern
- **Описание**: Адаптеры для внешних сервисов
- **Структура**:
  ```javascript
  // src/lib/storage/s3-adapter.js
  export class S3Adapter implements StorageAdapter {
    async upload(file) { /* ... */ }
    async download(path) { /* ... */ }
    async delete(path) { /* ... */ }
  }
  ```
- **Применение**: Хранилище файлов, кэширование, внешние API

### 4.2 Publisher-Subscriber (Redis PubSub)
- **Описание**: Асинхронная коммуникация через Redis PubSub
- **Реализация**:
  ```javascript
  // Публикация события
  await redisClient.publish('tournament:completed', JSON.stringify({
    id: tournament.id,
    name: tournament.name
  }));
  
  // Подписка на события
  redisClient.subscribe('tournament:completed');
  redisClient.on('message', (channel, message) => {
    if (channel === 'tournament:completed') {
      const data = JSON.parse(message);
      // Обработка события
    }
  });
  ```
- **Применение**: Уведомления, обновление кэша, фоновые задачи

### 4.3 Circuit Breaker
- **Описание**: Защита от каскадных сбоев внешних сервисов
- **Реализация**:
  ```javascript
  const breaker = new CircuitBreaker(
    async () => await s3Client.upload(file),
    {
      failureThreshold: 3,
      resetTimeout: 30000
    }
  );
  
  try {
    const result = await breaker.fire();
    return result;
  } catch (error) {
    // Fallback логика
    return await localStorageBackup.upload(file);
  }
  ```
- **Применение**: Интеграции с S3, внешними API, Redis 

### 4.4 Scheduled Jobs с BullMQ
- **Описание**: Планирование и выполнение фоновых задач с гарантированной доставкой
- **Преимущества**:
  - Персистентность задач в Redis
  - Атомарные операции с блокировками
  - Автоматические повторы при сбоях
  - Горизонтальное масштабирование
- **Структура**:
  - **Очереди** - раздельные очереди для разных типов задач
  - **Планировщики** - управление повторяющимися задачами
  - **Обработчики** - логика выполнения задач
  - **Мониторинг** - отслеживание выполнения через Bull Board
- **Применение**:
  - Автоматическая активация турниров и карт по расписанию
  - Периодическая очистка временных данных
  - Генерация отчетов и агрегация статистики 

**Пример структуры для формы создания/редактирования:**
```
├── components/
│   └── admin/
│       └── map-form/
│           ├── components/     # Презентационные компоненты
│           │   ├── MapFormBasicFields.jsx
│           │   ├── MapFormParticipants.jsx
│           │   └── MapFormStatistics.jsx
│           ├── hooks/          # Хуки с логикой
│           │   ├── useMapForm.js
│           │   └── useParticipants.js
│           ├── utils/          # Утилиты
│           │   └── mapFormHelpers.js
│           ├── MapFormContainer.jsx  # Контейнер с состоянием
│           └── MapFormView.jsx       # Презентационный компонент
``` 

## 5. Валидация на границе API (API Boundary Validation)

Для обеспечения надежности и предсказуемости API, вся валидация входящих данных происходит на самом внешнем уровне — в **API Route Handlers**.

*   **Инструмент**: `Zod`.
*   **Централизация**: Все Zod-схемы для конкретной сущности (например, `Player`) должны находиться в одном файле: `src/lib/api/schemas/{entity}/{entity-name}-schemas.js`.
*   **Принцип "Fail Fast"**: Запрос, не прошедший валидацию, немедленно отклоняется с ошибкой `400 Bad Request` и подробным описанием, какие поля неверны. Он никогда не достигает Domain-слоя.
*   **Единая обработка ошибок**: Все ошибки (включая ошибки валидации) в `try...catch` блоках маршрутов передаются в единый обработчик `handleApiError`, который формирует стандартизированный ответ.
*   **GET-запросы**: Валидация применяется не только к `POST`/`PUT` телам запроса, но и к query-параметрам `GET`-запросов для обеспечения полной целостности.

Этот паттерн защищает бизнес-логику от "грязных" данных и делает API строго типизированным и самодокументируемым. 

## 6. Будущие архитектурные улучшения (Предложения)

Этот раздел описывает предложенные паттерны, которые могут быть внедрены в будущем для дальнейшего повышения надежности, гибкости и управляемости системы.

### 6.1. Паттерн "Версионирование схемы" (Schema Versioning)
- **Приоритет:** **Высокий**.
- **Проблема:** Со временем бизнес-требования меняются, что приводит к необходимости изменять структуру документов (схем). Без версионирования, код, написанный под новую схему, может падать при обработке старых документов.
- **Решение:** Добавить в Mongoose-схемы поле `schemaVersion`.
  ```typescript
  // src/models/tournament/TournamentTemplate.ts
  const tournamentTemplateSchema = new Schema({
    // ... текущие поля
    schemaVersion: {
      type: Number,
      default: 1, // Текущая версия
      required: true,
    }
  });
  ```
- **Преимущества**:
  - **Обратная совместимость**: Приложение не падает при встрече со старыми данными.
  - **Управляемые миграции**: Упрощает написание скриптов для постепенного обновления старых документов до новой версии. Код может явно проверять `schemaVersion` и применять соответствующую логику.

### 6.2. Паттерн "Связанный шаблон и распространение изменений" (Template-Instance Linking)
- **Приоритет:** Средний.
- **Проблема:** При полном копировании данных из шаблона в экземпляр (например, из `TournamentTemplate` в `Tournament`), исправление опечатки в шаблоне требует ручного обновления всех созданных на его основе экземпляров.
- **Решение:**
  1. При создании экземпляра сохранять в нем ссылку на `templateId` и `templateVersion`.
  2. Реализовать механизм (ручной или фоновый) для "распространения" некритичных изменений (например, `description`) из шаблона в связанные с ним экземпляры.
- **Преимущества**:
  - **Централизованное управление**: Позволяет исправлять ошибки в одном месте.
  - **Экономия времени**: Сокращает ручной труд администраторов.

### 6.3. Паттерн "Аудит" (Audit Trail)
- **Приоритет:** **Высокий** (для production).
- **Проблема:** Отсутствие истории изменений. Невозможно отследить, кто, когда и какие данные изменил, что критично для безопасности и отладки.
- **Решение:** Создать отдельную коллекцию `AuditLog`. С помощью Mongoose-хуков (`post('save')`, `post('findOneAndUpdate')`) или на уровне `BaseRepo` автоматически создавать запись в этой коллекции при каждом важном изменении.
  ```json
  // Пример записи в AuditLog
  {
    "entity": "TournamentTemplate",
    "entityId": "605c72ef9f1b2c001f7b8b17",
    "action": "archive",
    "userId": "admin_user_id",
    "timestamp": "2023-10-27T10:00:00Z",
    "changes": { "isArchived": { "from": false, "to": true } }
  }
  ```
- **Преимущества**:
  - **Безопасность и подотчетность**: Всегда можно отследить историю изменений.
  - **Упрощение отладки**: Помогает понять, какое действие привело к неожиданному состоянию данных.
  