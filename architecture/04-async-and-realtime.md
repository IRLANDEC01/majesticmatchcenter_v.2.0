# Асинхронные операции и Real-time

Redis является основой для всех асинхронных операций и событий в реальном времени в приложении. Этот документ описывает использование Redis для управления фоновыми задачами и для обмена сообщениями.

## 1. Управление фоновыми задачами (BullMQ)

Для выполнения длительных или ресурсоемких операций, которые не должны блокировать основной поток приложения, используется библиотека **BullMQ**. Она построена поверх Redis и обеспечивает создание надежных, персистентных очередей задач.

### 1.1 Архитектура

*   **Очереди (Queues)**: Каждая очередь представляет собой определенный тип задач (например, `image-processing`, `send-email`). Очереди хранятся в Redis.
*   **Продюсеры (Producers)**: Любая часть приложения (например, API-эндпоинт) может добавить новую задачу в очередь.
*   **Воркеры (Workers)**: Специальные процессы, которые подписываются на очередь, получают из нее задачи и выполняют их. Воркеры могут работать в отдельных контейнерах для масштабирования.
*   **Мониторинг**: Для визуального отслеживания состояния очередей, задач и воркеров может использоваться `Bull Board`.

### 1.2 Планировщик задач

Для выполнения периодических задач (например, "активировать турниры каждый час") используется встроенный в BullMQ механизм **"Repeatable Jobs"**.

*   **Принцип работы**: Вместо внешнего `cron`-демона, при старте приложения запускается специальный скрипт (`scripts/scheduler.js`), который регистрирует в BullMQ все необходимые повторяющиеся задачи с их расписанием (`cron`-строка).
*   **Надежность**: BullMQ гарантирует, что задачи будут добавляться в очередь по расписанию, даже если приложение перезапускалось.

```javascript
// Пример регистрации повторяющейся задачи
await schedulerQueue.add('activate-tournaments', {}, {
  repeat: { cron: '0 * * * *' }, // Каждый час
  jobId: 'activate-tournaments' 
});
```

## 2. Система событий в реальном времени (Redis Pub/Sub)

Для мгновенного обмена сообщениями между различными частями системы (или разными экземплярами приложения) используется механизм **Redis Pub/Sub**.

### 2.1 Принцип работы

*   **Издатели (Publishers)**: Компонент, в котором произошло событие (например, `map-service` после завершения карты), публикует сообщение в определенный канал.
    ```javascript
    await redis.publish('map:completed', JSON.stringify({ mapId: '123' }));
    ```
*   **Подписчики (Subscribers)**: Другие компоненты подписываются на интересующие их каналы и слушают сообщения.
    ```javascript
    redis.subscribe('map:completed', (message) => {
      const { mapId } = JSON.parse(message);
      // Выполнить действие, например, инвалидировать кэш
    });
    ```
*   **Каналы (Channels)**: Именованные потоки сообщений (например, `map:completed`, `tournament:created`).

### 2.2 Основные сценарии использования

1.  **Мгновенная инвалидация кэша**: Вместо того чтобы ждать истечения TTL, сервис, изменяющий данные, может опубликовать событие, а сервис-подписчик, отвечающий за кэш, немедленно его инвалидирует.
2.  **Уведомления для WebSocket (Post-MVP)**: В будущем, WebSocket-сервер будет подписываться на события и отправлять уведомления подключенным клиентам в реальном времени. 