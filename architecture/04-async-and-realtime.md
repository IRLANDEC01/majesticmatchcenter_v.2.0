# Асинхронные операции и Real-time

Redis является основой для всех асинхронных операций и событий в реальном времени в приложении. Этот документ описывает использование Redis для управления фоновыми задачами и для обмена сообщениями.

## 1. Управление фоновыми задачами (BullMQ)

Для выполнения длительных или ресурсоемких операций, которые не должны блокировать основной поток приложения, используется библиотека **BullMQ**. Она построена поверх Redis и обеспечивает создание надежных, персистентных очередей задач.

### 1.1 Архитектура

*   **Очереди (Queues)**: Каждая очередь представляет собой определенный тип задач (например, `image-processing`, `send-email`). Очереди хранятся в Redis.
*   **Продюсеры (Producers)**: Любая часть приложения (например, API-эндпоинт) может добавить новую задачу в очередь.
*   **Воркеры (Workers)**: Специальные процессы, которые подписываются на очередь, получают из нее задачи и выполняют их. Воркеры могут работать в отдельных контейнерах для масштабирования.
*   **Мониторинг**: Для визуального отслеживания состояния очередей, задач и воркеров может использоваться `Bull Board`.

### 1.2 Планировщик задач

Для выполнения периодических задач (например, "активировать турниры каждый час") используется встроенный в BullMQ механизм **"Repeatable Jobs"**.

*   **Принцип работы**: Вместо внешнего `cron`-демона, при старте приложения запускается специальный скрипт (`scripts/scheduler.js`), который регистрирует в BullMQ все необходимые повторяющиеся задачи с их расписанием (`cron`-строка).
*   **Надежность**: BullMQ гарантирует, что задачи будут добавляться в очередь по расписанию, даже если приложение перезапускалось.

```javascript
// Пример регистрации повторяющейся задачи
await schedulerQueue.add('activate-tournaments', {}, {
  repeat: { cron: '0 * * * *' }, // Каждый час
  jobId: 'activate-tournaments' 
});
```

## 2. Система событий в реальном времени (Redis Pub/Sub)

Для мгновенного обмена сообщениями между различными частями системы (или разными экземплярами приложения) используется механизм **Redis Pub/Sub**.

### 2.1 Принцип работы

*   **Издатели (Publishers)**: Компонент, в котором произошло событие (например, `map-service` после завершения карты), публикует сообщение в определенный канал.
    ```javascript
    await redis.publish('map:completed', JSON.stringify({ mapId: '123' }));
    ```
*   **Подписчики (Subscribers)**: Другие компоненты подписываются на интересующие их каналы и слушают сообщения.
    ```javascript
    redis.subscribe('map:completed', (message) => {
      const { mapId } = JSON.parse(message);
      // Выполнить действие, например, инвалидировать кэш
    });
    ```
*   **Каналы (Channels)**: Именованные потоки сообщений (например, `map:completed`, `tournament:created`).

### 2.2 Основные сценарии использования

1.  **Мгновенная инвалидация кэша**: Вместо того чтобы ждать истечения TTL, сервис, изменяющий данные, может опубликовать событие, а сервис-подписчик, отвечающий за кэш, немедленно его инвалидирует.
2.  **Уведомления для WebSocket (Post-MVP)**: В будущем, WebSocket-сервер будет подписываться на события и отправлять уведомления подключенным клиентам в реальном времени. 

---

## 3. Real-time на клиенте (SWR)

Помимо серверных событий, мы активно используем клиентскую библиотеку **SWR** для создания "живого" и адаптивного интерфейса, особенно в административной панели.

### 3.1 Философия "Stale-While-Revalidate"

SWR реализует паттерн, который ставит **воспринимаемую производительность** в приоритет. Вместо того чтобы показывать пользователю загрузчик, SWR работает по следующему алгоритму:
1.  **Мгновенный показ**: При заходе на страницу SWR немедленно отображает данные из своего клиентского кэша (если они там есть). UI становится интерактивным в ту же секунду.
2.  **Фоновая ревалидация**: Одновременно SWR отправляет фоновый запрос к нашему API, чтобы проверить, не устарели ли данные.
3.  **Плавное обновление**: Если с сервера приходят обновленные данные, SWR плавно обновляет UI без полной перезагрузки страницы.

### 3.2 Решение проблем синхронизации в админ-панели

Этот подход элегантно решает две классические проблемы:

1.  **Проблема "AFK-администратора"**: Если администратор оставил вкладку открытой на несколько часов и вернулся к ней, SWR автоматически обнаружит событие "рефокуса" окна и инициирует фоновую ревалидацию. Пользователь увидит актуальные данные, которые могли измениться за время его отсутствия.
2.  **Проблема "нескольких администраторов"**: Если два администратора работают одновременно, изменения, сделанные одним, станут видны другому при его следующем взаимодействии со страницей или при автоматическом рефокусе. Для критически важных данных можно также настроить ревалидацию по интервалу (например, каждые 30 секунд).

Таким образом, SWR, в связке с серверной ревалидацией кэша Next.js, формирует комплексную систему, обеспечивающую как высокую производительность, так и актуальность данных. Мы используем два ключевых механизма:

1.  **`revalidatePath`**: Наш основной выбор для API-маршрутов (`route.js`). После любой мутации данных (создание, обновление, архивация) мы вызываем `revalidatePath('/path/to/list/page')`. Это принудительно инвалидирует серверный кэш для указанной страницы, гарантируя, что SWR на клиенте получит 100% актуальные данные при следующем запросе.

2.  **`revalidateTag`**: Используется для более гранулярных сценариев, когда одно изменение данных должно затронуть несколько разных, не связанных напрямую страниц, которые помечены одним тегом. 