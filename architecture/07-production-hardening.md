# Усиление безопасности и отказоустойчивости в Production

Этот документ описывает продвинутые практики, применяемые для повышения надежности, безопасности и наблюдаемости приложения в продакшен-среде.

## 1. Отказоустойчивость Redis (Redis Sentinel)

Для продакшен-среды единый экземпляр Redis является классической **единой точкой отказа (SPOF)**. При сбое Redis перестанут работать кэширование, очереди, сессии и real-time уведомления. Для решения этой проблемы внедряется **Redis Sentinel**.

### Архитектура высокой доступности (High Availability)

*   **1 Master-узел**: Принимает все операции записи и чтения.
*   **1+ Replica-узел**: Асинхронно копирует все данные с мастера. Может принимать на себя операции чтения для снижения нагрузки на мастер.
*   **3+ Sentinel-узла**: Легковесные процессы, которые постоянно наблюдают за состоянием мастера и реплик.

### Принцип работы

1.  **Мониторинг**: Сентинели постоянно проверяют доступность мастера.
2.  **Голосование**: Если кворум (большинство) сентинелей решает, что мастер недоступен, они инициируют процедуру переключения.
3.  **Повышение реплики**: Сентинели "голосуют" и выбирают одну из реплик, которую повышают до нового мастера.
4.  **Перенастройка**: Остальные реплики автоматически перенастраиваются на копирование данных с нового мастера. Клиенты, подключенные к сентинелям, также получают информацию о новом адресе мастера.

### Конфигурация клиента

Клиент `ioredis` в Node.js настраивается на подключение не к одному узлу Redis, а к списку сентинелей.

```javascript
import Redis from 'ioredis';

const client = new Redis({
  sentinels: [
    { host: 'redis-sentinel-1', port: 26379 },
    { host: 'redis-sentinel-2', port: 26379 },
    { host: 'redis-sentinel-3', port: 26379 },
  ],
  name: 'mymaster', // Имя группы, которое знают сентинели
});
```

## 2. Безопасное управление секретами (Docker Secrets)

Хранение секретов (пароли, ключи API) в переменных окружения или `.env` файлах в продакшене небезопасно. Рекомендуемый подход — использование **Docker Secrets**.

### Принцип работы

1.  **Хранение**: Секреты хранятся в зашифрованном виде в менеджере Docker (Swarm или Kubernetes). При использовании `docker-compose` их можно эмулировать с помощью файлов.
2.  **Монтирование**: Docker монтирует секреты в контейнеры как временные файлы в памяти по пути `/run/secrets/<secret_name>`.
3.  **Чтение**: Приложение читает секрет напрямую из файла.

### Пример реализации

**`docker-compose.prod.yml`:**
```yaml
services:
  app:
    # ...
    secrets:
      - redis_password

secrets:
  redis_password:
    file: ./secrets/redis_password.txt
```

**Чтение секрета в Node.js:**
```javascript
import fs from 'fs';

function getRedisPassword() {
  const secretPath = '/run/secrets/redis_password';
  if (fs.existsSync(secretPath)) {
    // Читаем из секрета Docker
    return fs.readFileSync(secretPath, 'utf8').trim();
  }
  // Fallback на переменную окружения для dev-режима
  return process.env.REDIS_PASSWORD;
}
```

## 3. Централизованное логирование (Grafana Loki)

Для эффективной отладки и мониторинга все логи приложения и инфраструктуры должны собираться в единой системе. Стек **Grafana Loki** является современным, производительным и легковесным решением.

### Процесс настройки

1.  **Приложение (Winston)**: Основной логгер приложения настраивается на вывод структурированных **JSON-логов** в `stdout`. Это позволяет добавлять к логам метаданные (ID запроса, ID пользователя и т.д.).
2.  **Docker**: Для каждого сервиса в `docker-compose.prod.yml` настраивается `logging driver` для перенаправления `stdout` потока в Loki.
3.  **Инфраструктура**: Развертываются три компонента:
    *   `Loki`: Основной сервис, который принимает, сжимает и хранит логи.
    *   `Promtail`: Агент, который "собирает" логи с хоста или из Docker и отправляет их в Loki.
    - `Grafana`: Инструмент для визуализации, в котором настраивается источник данных Loki для поиска и анализа логов.

### Пример конфигурации

**`winston.js`:**
```javascript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  // Вывод в формате JSON
  format: winston.format.json(), 
  transports: [
    // Всегда пишем в стандартный вывод (консоль)
    new winston.transports.Console(), 
  ],
});
```
**`docker-compose.prod.yml`:**
```yaml
services:
  app:
    # ...
    logging:
      driver: "loki"
      options:
        loki-url: "http://loki:3100/loki/api/v1/push"
```
Этот подход обеспечивает полную "наблюдаемость" (observability) системы. 