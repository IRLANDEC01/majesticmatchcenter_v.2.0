# Паттерн "Outcome-Driven Prize Pool"

## Проблема

В системе турниров необходимо гибко настраивать распределение призового фонда. Жестко закодированные варианты (например, `winner_takes_all` или `top_3`) не позволяют администраторам легко создавать кастомные схемы вознаграждения, такие как "Топ-3 получают фиксированные суммы, а оставшиеся 17 участников делят поровну утешительный приз". Любое изменение требовало бы доработки кода.

## Решение: Гибкая модель на основе исходов (Outcomes)

Мы используем паттерн, где логика распределения призов определяется исключительно данными, а не кодом. Этот подход состоит из двух частей: **Правила** и **Исходы**.

### 1. Правила (Prize Pool Rules)

В модели `TournamentTemplate` (шаблон турнира) существует поле `prizePool`. Это массив объектов, где каждый объект — это "правило", описывающее награду за определенное достижение.

**Структура правила:**
```javascript
{
  target: {
    tier: String, // Категория ("winner", "runner-up", "top_scorer", "pot")
    rank: Number, // Конкретное место (опционально, для tier='winner' и т.д.)
  },
  amount: Number, // Сумма приза
  currency: String, // Валюта
}
```

**Пример `prizePool` в шаблоне:**
```json
"prizePool": [
  { "target": { "tier": "winner", "rank": 1 }, "amount": 1000000 },
  { "target": { "tier": "runner-up", "rank": 2 }, "amount": 500000 },
  { "target": { "tier": "runner-up", "rank": 3 }, "amount": 250000 },
  { "target": { "tier": "pot" }, "amount": 500000 } // Общий банк для остальных
]
```

### 2. Исходы (Outcomes)

Когда администратор завершает турнир через API `POST /api/admin/tournaments/:id/complete`, он передает в теле запроса массив `outcomes`. Этот массив — это фактический результат турнира.

**Структура `outcomes`:**
```javascript
// Тело запроса
{
  "outcomes": [
    { "familyId": "...", "tier": "winner", "rank": 1 },
    { "familyId": "...", "tier": "runner-up", "rank": 2 },
    { "familyId": "...", "tier": "runner-up", "rank": 3 },
    { "familyId": "...", "tier": "participant" },
    { "familyId": "...", "tier": "participant" }
  ]
}
```

### 3. Процесс

1.  Бэкенд получает запрос на завершение турнира с массивом `outcomes`.
2.  `TournamentService` загружает турнир и его `prizePool` из шаблона.
3.  Сервис итерирует по массиву `outcomes`.
4.  Для каждого исхода он ищет соответствующее правило в `prizePool`.
    *   Если находит прямое совпадение (например, `tier: 'winner', rank: 1`), он начисляет указанную сумму.
    *   Если участник не попал ни под одно из правил, но есть правило `tier: 'pot'`, он будет добавлен в список претендентов на "утешительный приз".
5.  После распределения всех ранговых призов, сумма из `pot` делится поровну между всеми оставшимися участниками.
6.  Все начисления записываются в `FamilyEarning` и обновляют `FamilyTournamentParticipation`.

## Преимущества

*   **Гибкость:** Администраторы могут создавать любые схемы призовых через UI, не привлекая разработчиков.
*   **Надежность:** Логика отделена от данных. Код остается простым и занимается только сопоставлением правил и исходов.
*   **Масштабируемость:** Легко добавить новые `tier` (например, "mvp_award") без изменения существующей логики. 