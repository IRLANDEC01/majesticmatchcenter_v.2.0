# Бизнес-логика: Ключевые концепции

Этот документ описывает высокоуровневые бизнес-концепции и правила, применимые ко всему приложению. Детальная бизнес-логика для конкретных сущностей вынесена в отдельные специализированные документы для упрощения поддержки и навигации.

*Данный документ является источником правды для общих правил. Специфику следует искать в дочерних документах.*

---

## 1. Детализированная бизнес-логика по сущностям

Для получения подробной информации о жизненных циклах, правилах и пограничных случаях для конкретных доменных областей, пожалуйста, обратитесь к следующим документам:

*   **[Семьи и Игроки](./business-logic/01-families-and-players.md)**
    *   *Содержит: жизненный цикл семьи, управление составом и владельцем, правила архивации семей и игроков.*

*   **[Турниры и Шаблоны Турниров](./business-logic/02-tournaments-and-templates.md)**
    *   *Содержит: типы турниров (семейные, командные), жизненный цикл турнира от создания до ручного завершения, управление картами в рамках турнира.*

*   **[Карты и Шаблоны Карт](./business-logic/03-maps-and-templates.md)**
    *   *Содержит: жизненный цикл карты, правила ручного завершения, процесс начисления рейтинга и турнирных очков администратором.*

*   **[Паттерн "Призовой фонд"](./05b-business-logic-prizepool-pattern.md)**
    *   *Содержит: описание структуры `prizePool` для гибкой настройки наград.*

*   **[Модель "Результаты Участника"](./05c-business-logic-outcome-model.md)**
    *   *Содержит: описание структуры `Outcome`, агрегирующей все результаты участника в турнире.*

---

## 2. Общие бизнес-правила

### 2.1. Мягкое удаление (Soft Deletion)

*   **Правило:** Ни одна ключевая сущность (`Player`, `Family`, `Tournament`, `Map` и т.д.) не удаляется из базы данных физически.
*   **Реализация:** Используется "мягкое удаление" через установку поля `archivedAt` (или `isArchived`).
*   **Обоснование:** Сохранение исторических данных для статистики, аналитики и возможного восстановления.

### 2.2. Уникальные идентификаторы (Slugs)

*   **Правило:** Все публично доступные сущности (профили игроков, семей, страницы турниров) должны иметь человеко-понятный и уникальный идентификатор (`slug`) для использования в URL.
*   **Реализация:** `slug` генерируется автоматически из названия (`name`) при создании сущности.
*   **Важно:** `slug` должен быть **неизменяемым (immutable)**. Даже если название сущности меняется, `slug` остается прежним, чтобы не ломать существующие ссылки.

### 2.3. Валидация на уровне сервисов

*   **Правило:** Вся бизнес-валидация (проверки, которые не являются простой проверкой формата данных) должна происходить в сервисном слое (`*-service.js`).
*   **Пример:** Проверка, что нельзя добавить архивного игрока в семью.
*   **Обоснование:** Защита целостности бизнес-логики и предотвращение некорректных состояний данных.

---

## 3. Бизнес-правила и ограничения

### 3.1 Правила участия

#### Игроки
- Игрок может состоять только в одной активной семье
- Игрок может участвовать в нескольких турнирах
- Игрок может быть в разных командах в разных турнирах

#### Семьи
- Семья может участвовать в нескольких турнирах одновременно

#### Команды
- Команда существует только в рамках одного турнира
- Команда имеет временный состав без истории изменений
- Игрок может быть в разных командах в разных турнирах

### 3.2 Правила турниров и карт

#### Турниры
- Турнир может содержать произвольное количество карт
- Турнир не может быть завершен без хотя бы одной завершенной карты
- Турнир может иметь только одного победителя (семья или команда)
- Статус турнира автоматически меняется на active при наступлении даты начала

#### Карты
- Карта должна быть привязана к турниру
- Карта не может быть завершена без выбранного MVP и Победителя. Загрузка статистики и начисление рейтинга семьям являются опциональными.
- Карта может иметь только одного победителя (семья или команда)
- Статус карты автоматически меняется на active при наступлении времени начала

### 3.3 Правила автоматического управления статусами

#### Автоматические изменения статусов
- Статус турнира меняется с planned на active автоматически при наступлении даты начала
- Статус карты меняется с planned на active автоматически при наступлении времени начала
- Статус completed устанавливается только вручную администратором
- При изменении даты/времени статус может быть автоматически скорректирован

#### Правила изменения расписания
- При переносе турнира/карты на более позднюю дату статус не меняется с active на planned
- При переносе турнира/карты на более раннюю дату статус может измениться с planned на active
- Завершенные турниры/карты (статус completed) не меняют статус при изменении расписания

### 3.4 Правила статистики

#### Игровая статистика
- Минимальный набор статистики: kills, deaths, damageDealt
- Детальная статистика включает: shotsFired, hits, headshots, weaponStats
- Виртуальные поля для расчетов: kdRatio, accuracy, headshotRate
- Статистика агрегируется на нескольких уровнях: карта, турнир, месяц, год

#### Месячная и годовая статистика
- Месячная статистика обновляется инкрементально при каждом участии
- Годовая статистика кэшируется в currentYearStats и обновляется инкрементально
- Завершенные годы "замораживаются" в yearlyArchive
- Доступна история по месяцам и годам через виртуальные поля

### 3.5 Система статистики и достижений

#### Статистика игроков
- **Общая статистика**:
  - Базовые метрики: kills, deaths, damage, maps played, wins
  - Рейтинг: текущий рейтинг, история изменений, пиковый рейтинг
  - Агрегированные метрики: K/D ratio, win rate, damage per map
  - Достижения: количество MVP, топ-3 результаты, награды

- **Статистика по оружию**:
  - Отслеживание по каждому оружию: kills, damage, shots fired, hits, headshots
  - Расчетные метрики: accuracy, headshot rate, damage per shot
  - Временные срезы: за все время, по месяцам, по годам
  - Любимое оружие и наиболее эффективное оружие

- **Временная статистика**:
  - Месячная статистика: kills, deaths, damage, maps played по месяцам
  - Годовая статистика: агрегированная статистика за текущий год
  - Архив годовой статистики: "замороженные" данные за прошлые годы
  - Тренды: изменение ключевых метрик во времени

- **Статистика участия в семьях**:
  - История членства: даты вступления и ухода из семей
  - Статистика выступлений за каждую семью: maps played, wins, K/D
  - Достижения в составе семей: командные награды, личные награды
  - Наиболее успешная семья для игрока

#### Статистика семей
- **Общая статистика**:
  - Базовые метрики: maps played, wins, win rate
  - Рейтинг: текущий рейтинг, история изменений, пиковый рейтинг
  - Турнирная статистика: участия, победы, призовые места
  - Коллективные достижения: MVP турниров, серии побед

- **Временная статистика**:
  - Месячная активность: количество карт и турниров по месяцам
  - Годовая статистика: агрегированная статистика за текущий год
  - Архив годовой статистики: данные за прошлые годы
  - Тренды: изменение активности и результативности во времени

- **Статистика участников**:
  - История членства: все игроки, когда-либо состоявшие в семье
  - Текущий состав: активные игроки семьи
  - Наиболее результативные игроки: по kills, damage, K/D
  - MVP семьи: игроки с наибольшим количеством наград MVP

#### Система достижений
- **Индивидуальные достижения**:
  - **Карточные**: MVP карты, лучший стрелок, лучший K/D, наибольший урон
  - **Турнирные**: MVP турнира, лучший стрелок турнира, наибольший вклад
  - **Временные**: лучший игрок месяца, прогресс года, серии побед
  - **Оружейные**: мастер снайпера, эксперт штурмовой винтовки, точность стрельбы

- **Командные достижения**:
  - **Победы**: победитель карты, победитель турнира, серия побед
  - **Стабильность**: высокий винрейт, длительные серии без поражений
  - **Коллективные**: лучшая командная игра, синергия состава
  - **Прогресс**: улучшение результатов, рост рейтинга

#### Рейтинговые таблицы
- **Топы игроков**:
  - По рейтингу: общий рейтинг игроков
  - По урону: наибольший средний урон за карту
  - По убийствам: наибольшее количество убийств
  - По картам: наибольшее количество сыгранных карт
  - Временные срезы: за все время, за месяц, за год

- **Топы семей**:
  - По рейтингу: общий рейтинг семей
  - По победам: наибольшее количество побед
  - По картам: наибольшее количество сыгранных карт
  - По винрейту: наилучшее соотношение побед к играм
  - Временные срезы: за все время, за месяц, за год

- **Отображение на главной странице**:
  - Топ-10 семей по рейтингу, сыгранным картам и победам
  - Топ-20 игроков по рейтингу, урону, убийствам и сыгранным картам
  - Переключение между временными срезами: все время, месяц, год
  - Автоматическое обновление после завершения карты или турнира

## 4. Доменные сервисы

### 4.1 TournamentService

**Назначение:** Управление жизненным циклом турниров, включая создание, активацию и завершение.

**Ключевые методы:**
```javascript
class TournamentService {
  constructor(tournamentRepo, familyRepo, playerRepo) { /* ... */ }
  async createTournament(data) { /* ... */ }
  async activateTournament(id) { /* ... */ }
  async completeTournament(id, winnerId, winnerType) { /* ... */ }
  async getParticipantsFromMaps(tournamentId) { /* ... */ }
}
```

**Функциональность:**
- **createTournament** - Создает новый турнир с указанными параметрами, валидирует данные, добавляет участников и публикует событие о создании.
- **activateTournament** - Активирует турнир, проверяя его текущий статус и наличие минимального количества участников.
- **completeTournament** - Завершает турнир, определяет победителя, распределяет призы и обновляет статистику участников.
- **getParticipantsFromMaps** - Агрегирует уникальных участников из всех карт турнира для формирования полного списка участников.

### 4.2 MapService

**Назначение:** Управление жизненным циклом карт, включая создание, активацию, загрузку статистики и завершение.

**Ключевые методы:**
```javascript
class MapService {
  constructor(mapRepo, tournamentRepo, playerRepo, ratingService) { /* ... */ }
  async createMap(data) { /* ... */ }
  async activateMap(id) { /* ... */ }
  async uploadStatistics(id, statistics) { /* ... */ }
  async completeMap(id, winnerId, winnerType, ratingChanges) { /* ... */ }
}
```

**Функциональность:**
- **createMap** - Создает новую карту в рамках активного турнира, проверяет валидность данных и добавляет участников.
- **activateMap** - Меняет статус карты на "active", проверяя наличие необходимых участников.
- **uploadStatistics** - Загружает и валидирует игровую статистику, сопоставляет данные с игроками.
- **completeMap** - Завершает карту, определяет победителя, обновляет рейтинги и статистику, создает записи участия.

### 4.3 RatingService

**Назначение:** Управление рейтингами игроков и семей, включая начисление и отмену изменений.

**Ключевые методы:**
```javascript
class RatingService {
  constructor(playerRepo, familyRepo, historyRepo) { /* ... */ }
  async updatePlayerRatings(mapId, statistics) { /* ... */ }
  async updateFamilyRatings(mapId, ratingChanges) { /* ... */ }
  async rollbackMapRatings(mapId) { /* ... */ }
}
```

**Функциональность:**
- **updatePlayerRatings** - Начисляет рейтинг игрокам на основе их убийств (1 kill = 1 рейтинг), обновляет профиль и создает запись в истории.
- **updateFamilyRatings** - Применяет изменения рейтинга к семьям, заданные администратором, обновляет профили и создает записи в истории.
- **rollbackMapRatings** - Отменяет все изменения рейтинга, связанные с конкретной картой, для игроков и семей.

### 4.4 ParticipationService

**Назначение:** Управление записями об участии игроков и семей в турнирах и картах.

**Ключевые методы:**
```javascript
class ParticipationService {
  constructor(playerParticipationRepo, familyParticipationRepo) { /* ... */ }
  async addMapParticipation(playerId, mapId, statistics) { /* ... */ }
  async addFamilyMapParticipation(familyId, mapId, isWinner) { /* ... */ }
  async rollbackMapParticipations(mapId) { /* ... */ }
}
```

**Функциональность:**
- **addMapParticipation** - Создает или обновляет запись об участии игрока в карте, обновляет месячную и годовую статистику.
- **addFamilyMapParticipation** - Создает или обновляет запись об участии семьи в карте, обновляет статистику.
- **rollbackMapParticipations** - Удаляет все записи участия, связанные с картой, и пересчитывает агрегированную статистику.

### 4.5 PrizeService

**Назначение:** Управление призовым фондом и распределением призов между участниками.

**Ключевые методы:**
```javascript
class PrizeService {
  constructor(playerRepo, tournamentRepo) { /* ... */ }
  async allocatePrizes(tournamentId, allocations) { /* ... */ }
  async rollbackPrizes(tournamentId) { /* ... */ }
}
```

**Функциональность:**
- **allocatePrizes** - Распределяет призы между игроками семей/команд, равномерно деля сумму между всеми участниками.
- **rollbackPrizes** - Отменяет все призовые начисления, связанные с конкретным турниром, и обновляет профили игроков.

### 4.6 SchedulerService

**Назначение:** Автоматическое управление статусами турниров и карт на основе их запланированного времени.

**Ключевые методы:**
```javascript
class SchedulerService {
  constructor(tournamentRepo, mapRepo, eventBus) { /* ... */ }
  async checkAndUpdateStatuses() { /* ... */ }
  async updateTournamentStatuses(now) { /* ... */ }
  async updateMapStatuses(now) { /* ... */ }
  hasMinimumParticipants(entity) { /* ... */ }
  async createStatusHistoryRecord(data) { /* ... */ }
}
```

**Функциональность:**
- **checkAndUpdateStatuses** - Запускает проверку и обновление статусов для турниров и карт.
- **updateTournamentStatuses** - Находит запланированные турниры с датой начала в прошлом и активирует их.
- **updateMapStatuses** - Находит запланированные карты с временем начала в прошлом и активирует их.
- **hasMinimumParticipants** - Проверяет наличие минимального количества участников для активации.
- **createStatusHistoryRecord** - Создает запись в журнале изменений статусов для аудита.

### 4.7 StatusHistoryService

**Назначение:** Управление историей изменений статусов для турниров и карт.

**Ключевые методы:**
```javascript
class StatusHistoryService {
  constructor(statusHistoryRepo) { /* ... */ }
  async createRecord(data) { /* ... */ }
  async getHistoryForEntity(entityType, entityId) { /* ... */ }
  async getRecentAutomaticChanges(limit = 50) { /* ... */ }
}
```

**Функциональность:**
- **createRecord** - Создает новую запись в истории изменений статуса с указанием типа сущности, старого и нового статуса.
- **getHistoryForEntity** - Получает полную историю изменений статусов для конкретной сущности.
- **getRecentAutomaticChanges** - Возвращает последние автоматические изменения статусов для отображения в интерфейсе администратора.

## 5. Интеграция с Redis

### 5.1 Кэширование доменных объектов

```javascript
// src/lib/repos/tournament-repo.js
export class TournamentRepository {
  constructor(cache) {
    this.cache = cache;
  }
  
  async findById(id) {
    const cacheKey = `tournament:${id}`;
    
    // Попытка получить из кэша
    const cached = await this.cache.get(cacheKey);
    if (cached) return cached;
    
    // Получение из БД
    const tournament = await Tournament.findById(id)
      .populate('participantFamilies.family')
      .lean();
    
    if (tournament) {
      // Сохранение в кэш с тегами
      await this.cache.set(cacheKey, tournament, {
        ttl: 300, // 5 минут
        tags: ['tournament', `tournament:${id}`]
      });
    }
    
    return tournament;
  }
  
  async update(id, data) {
    // Обновление в БД
    const tournament = await Tournament.findByIdAndUpdate(id, data, { new: true });
    
    // Инвалидация кэша
    await this.cache.invalidateByTag(`tournament:${id}`);
    
    return tournament;
  }
}
```

### 5.2 Публикация доменных событий

```javascript
// src/lib/domain/tournament-service.js
export class TournamentService {
  constructor(tournamentRepo, familyRepo, playerRepo, pubSub) {
    this.tournamentRepo = tournamentRepo;
    this.familyRepo = familyRepo;
    this.playerRepo = playerRepo;
    this.pubSub = pubSub;
  }
  
  async completeTournament(id, winnerId, winnerType) {
    // ... существующая логика
    
    // Публикация события
    await this.pubSub.publish('tournament:completed', {
      id: tournament._id.toString(),
      name: tournament.name,
      winner: {
        id: winnerId,
        type: winnerType,
        name: winnerName
      }
    });
    
    // Инвалидация связанных кэшей
    await this.cache.invalidateByTag(`tournament:${id}`);
    await this.cache.invalidateByTag('tournaments');
    
    return tournament;
  }
}
```

### 5.3 Обработка доменных событий

```javascript
// src/lib/event-handlers/tournament-events.js
export function setupTournamentEventHandlers(pubSub, cache, notificationService) {
  // Подписка на события завершения турнира
  pubSub.subscribe('tournament:completed', async (data) => {
    // Инвалидация кэша
    await cache.invalidateByTag(`tournament:${data.id}`);
    await cache.invalidateByTag('tournaments');
    
    // Отправка уведомлений
    await notificationService.sendNotification({
      type: 'TOURNAMENT_COMPLETED',
      title: `Турнир "${data.name}" завершен`,
      message: `Победитель: ${data.winner.name}`,
      data: {
        tournamentId: data.id,
        winnerId: data.winner.id,
        winnerType: data.winner.type
      }
    });
  });
}
```

### 5.4 Расширение репозиториев для автоматического управления статусами

```javascript
// src/lib/repos/tournament-repo.js
export class TournamentRepository {
  // ... существующие методы
  
  async findPlannedWithStartDateBefore(date) {
    const tournaments = await Tournament.find({
      status: 'planned',
      startDate: { $lte: date }
    }).lean();
    
    return tournaments;
  }
  
  async updateStatus(id, status) {
    const tournament = await Tournament.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    );
    
    // Инвалидация кэша
    await this.cache.invalidateByTag(`tournament:${id}`);
    
    return tournament;
  }
}

// src/lib/repos/map-repo.js
export class MapRepository {
  // ... существующие методы
  
  async findPlannedWithStartTimeBefore(date) {
    const maps = await Map.find({
      status: 'planned',
      startDateTime: { $lte: date }
    }).lean();
    
    return maps;
  }
  
  async updateStatus(id, status) {
    const map = await Map.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    );
    
    // Инвалидация кэша
    await this.cache.invalidateByTag(`map:${id}`);
    
    return map;
  }
}

### 5.5 Интеграция планировщика с BullMQ

**Назначение:** Настройка и инициализация очередей BullMQ для автоматического управления статусами.

**Ключевые компоненты:**

1. **Очереди для обработки статусов:**
   - `status:tournaments` - очередь для проверки и обновления статусов турниров
   - `status:maps` - очередь для проверки и обновления статусов карт

2. **Повторяющиеся задачи:**
   ```javascript
   // Пример настройки повторяющейся задачи
   tournamentStatusQueue.add(
     'check-tournament-statuses',
     {},
     {
       jobId: 'recurring-tournament-status-check',
       repeat: {
         every: 30000 // 30 секунд
       }
     }
   );
   ```

3. **Обработчики задач:**
   - Обрабатывают задачи из очередей
   - Вызывают соответствующие методы доменных сервисов
   - Обрабатывают и логируют ошибки

4. **Предотвращение дублирования:**
   - Использование уникальных jobId для повторяющихся задач
   - Блокировки Redis для предотвращения одновременного выполнения

5. **Мониторинг и логирование:**
   - Обработка событий `completed` и `failed`
   - Структурированное логирование с контекстом задачи

### 5.6 Обработка событий изменения статуса

**Назначение:** Обработка событий, возникающих при изменении статусов турниров и карт.

**Ключевые операции:**

1. **Подписка на события:**
   - `tournament.status.changed` - событие изменения статуса турнира
   - `map.status.changed` - событие изменения статуса карты

2. **Действия при изменении статуса:**
   - Инвалидация соответствующих записей в кэше
   - Логирование события с контекстом
   - Обновление связанных сущностей (при необходимости)

3. **Пример подписки на события:**
   ```javascript
   eventBus.subscribe('tournament.status.changed', async (data) => {
     // Инвалидация кэша
     await cache.invalidateByTag(`tournament:${data.id}`);
     // Логирование события
     logger.info(`Tournament status changed: ${data.oldStatus} -> ${data.newStatus}`);
   });
   ```

### 5.7 Запуск планировщика в приложении

**Назначение:** Интеграция планировщика задач в основное приложение Next.js.

**Ключевые компоненты:**

1. **Инициализация сервисов:**
   - Подключение к MongoDB и Redis
   - Создание репозиториев и доменных сервисов
   - Настройка обработчиков событий

2. **Настройка BullMQ:**
   - Инициализация очередей и обработчиков
   - Настройка повторяющихся задач

3. **Мониторинг с Bull Board:**
   - Интеграция с Express для доступа к панели мониторинга
   - Защита доступа с помощью базовой аутентификации
   ```javascript
   // Пример настройки Bull Board
   const serverAdapter = new ExpressAdapter();
   serverAdapter.setBasePath('/admin/queues');
   
   createBullBoard({
     queues: [
       new BullMQAdapter(tournamentStatusQueue),
       new BullMQAdapter(mapStatusQueue)
     ],
     serverAdapter
   });
   ```

4. **Корректное завершение работы:**
   - Обработка сигналов SIGTERM и SIGINT
   - Закрытие подключений к BullMQ, Redis и MongoDB
   - Логирование процесса завершения работы

## 6. Стратегия обработки ошибок

Для обеспечения чистоты кода и предсказуемого поведения, в проекте используется централизованная стратегия обработки ошибок.

### 6.1 Принцип работы

Паттерн четко разделяет ответственности между слоями приложения:

1.  **Доменный слой (Сервисы)**: Единственный слой, ответственный за принятие решений о бизнес-ошибках. Когда сервис обнаруживает нарушение бизнес-правила (например, попытка создать запись с дублирующимся `slug`), он выбрасывает **семантическую кастомную ошибку**.
2.  **Словарь ошибок (`src/lib/errors.js`)**: Содержит определения кастомных классов ошибок, таких как `DuplicateError`, `NotFoundError`, `ValidationError`. Это делает код самодокументируемым.
3.  **Центральный обработчик (`src/lib/api/handle-api-error.js`)**: "Переводчик", который получает кастомную ошибку от сервиса и преобразует ее в корректный HTTP-ответ с соответствующим статусом и сообщением.
4.  **API Слой (Route Handlers)**: Маршруты становятся максимально "тонкими". Их единственная задача — обернуть вызов сервиса в блок `try...catch` и передать любую возникшую ошибку в центральный обработчик `handleApiError`.

### 6.2 Пример потока ошибки

```
┌─────────────────┐   1. Вызывает метод   ┌────────────────────┐
│ Route Handler   ├─────────────────────► │    MapService      │
│ (api/.../route) │                       │ (доменный сервис)  │
└────────┬────────┘                       └──────────┬─────────┘
         │                                          │ 2. Проверяет slug,
         │                                          │    находит дубликат
         │ 5. Возвращает готовый                    │
         │    HTTP Response (409)                    │ 3. throw new DuplicateError()
         │                                          ▼
┌────────┴────────┐   4. Преобразует    ┌────────────────────┐
│ handleApiError  │ ◄───────────────────┤   DuplicateError   │
│ (обработчик)    │   ошибку в Response │(кастомная ошибка)  │
└─────────────────┘                       └────────────────────┘
```

### 6.3 Преимущества

- **Чистый код (DRY)**: Логика обработки конкретной ошибки находится в одном месте, а не разбросана по множеству маршрутов.
- **Разделение ответственностей**: Сервисы отвечают за бизнес-логику, обработчики — за HTTP-представление. API-маршруты остаются простыми и чистыми.
- **Надежность и предсказуемость**: Легко добавлять новые типы ошибок и быть уверенным, что они будут обработаны корректно во всем приложении.

---
 
### 4.3 Модульная архитектура компонентов

**Принципы организации компонентов:**

1. **Разделение ответственности:**
   - **Контейнерные компоненты** - управляют состоянием и бизнес-логикой
   - **Презентационные компоненты** - отвечают только за отображение UI
   - **Хуки** - инкапсулируют логику работы с данными и состоянием

2. **Структура модулей:**
   - **Компоненты** - изолированные презентационные части интерфейса
   - **Хуки** - переиспользуемая логика для работы с данными
   - **Утилиты** - вспомогательные функции для обработки данных

3. **Организация файлов:**
   - Группировка по функциональности и доменной области
   - Компоненты верхнего уровня в корне папки
   - Вложенные компоненты в подпапке components
   - Связанные хуки в подпапке hooks
   - Утилиты в подпапке utils

4. **Правила именования:**
   - Контейнерные компоненты с суффиксом Container
   - Презентационные компоненты с суффиксом View
   - Хуки с префиксом use
   - Утилиты с суффиксом Helpers или Utils

5. **Передача данных:**
   - Контейнеры получают данные через API или хуки
   - Презентационные компоненты получают данные только через props
   - Избегание глубокой передачи props через использование композиции

**Пример структуры для формы создания/редактирования:**
```
├── компоненты/
│   └── админ/
│       └── ФормаКарты/
│           ├── компоненты/     # Презентационные компоненты
│           │   ├── БазовыеПоля.jsx
│           │   ├── БлокУчастников.jsx
│           │   └── БлокСтатистики.jsx
│           ├── хуки/           # Хуки с логикой
│           │   ├── использованиеФормы.js
│           │   └── использованиеУчастников.js
│           ├── утилиты/        # Утилиты
│           │   └── вспомогательныеФункции.js
│           ├── Контейнер.jsx   # Контейнер с состоянием
│           └── Представление.jsx # Презентационный компонент
``` 