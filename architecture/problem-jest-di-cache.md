# Диагностика: Глубокая проблема с кешем модулей Jest и DI-контейнером

## 1. Цель

Обеспечить надежное и изолированное интеграционное тестирование для API-маршрутов Next.js (`/api/.../route.js`). Тесты должны использовать DI-контейнер для разрешения зависимостей (сервисов, репозиториев) и работать с реальной, но изолированной тестовой базой данных.

## 2. Ключевая проблема

Несмотря на многочисленные попытки рефакторинга, тесты для двух ключевых маршрутов (`/maps/[id]/complete` и `/maps/[id]/rollback`) стабильно падают с двумя типами ошибок:

1.  **`TypeError: Cannot read properties of undefined (reading '...')`**:
    *   **Пример:** `...reading 'upsert'` в `rating-service.js`.
    *   **Значение:** Сервис (`RatingService`) вызывается, но его зависимость (например, `familyMapParticipationRepo`) равна `undefined`. Это классический симптом сбоя внедрения зависимостей.

2.  **`MongooseError: Operation \`...\` buffering timed out after 10000ms`**:
    *   **Значение:** Код пытается выполнить операцию с базой данных, но не может установить/найти активное соединение. Это также может быть симптомом того, что репозиторий, который управляет соединением, не был правильно внедрен.

Эти ошибки возникают **только** в среде Jest. Приложение в режиме разработки может работать корректно.

## 3. Что было сделано (и почему не сработало)

### Попытка №1: Внедрение DI-контейнера и `jest.resetModules()`

- **Действие:** Мы отказались от синглтонов и внедрили DI-контейнер (`/lib/di-container.js`). В каждом проблемном тестовом файле мы добавили блок `beforeEach`, который сбрасывает кеш модулей перед каждым тестом.

  ```javascript
  beforeEach(async () => {
    jest.resetModules(); // Сбрасываем кеш
    const container = require('@/lib/di-container').default; // Загружаем "свежий" контейнер
    mapService = container.get('mapService'); // Получаем "свежий" сервис
    await clearDatabase();
    // ... создание тестовых данных
  });
  ```

- **Ожидание:** Каждый тест будет работать с полностью новым, правильно сконфигурированным набором сервисов, что гарантирует изоляцию и корректное внедрение зависимостей.
- **Результат:** Ошибка не исчезла.

### Попытка №2: Отладочное логирование

- **Действие:** Мы добавили `console.log` в конструкторы `MapService` и `RatingService`, чтобы посмотреть, какие зависимости они получают во время выполнения тестов.
- **Результат (Ключевое открытие):** Логи показали, что в момент инициализации в `beforeEach` **все зависимости на месте**. `RatingService` получает все свои репозитории, а `MapService` получает корректный `RatingService`. Однако, когда тест запускает код в API-маршруте, `RatingService` оказывается "пустым".

Это доказывает, что **экземпляр сервиса в тесте и экземпляр в API-маршруте — это два разных экземпляра**.

### Попытка №3: Рефакторинг API-маршрутов

- **Действие:** Мы изменили код в `complete/route.js` и `rollback/route.js`, чтобы они получали сервис не на уровне модуля, а непосредственно внутри функции-обработчика.

  ```javascript
  // Было
  // const mapService = container.get('mapService'); // Вызывалось один раз при загрузке модуля
  // export async function POST(...) { await mapService.doWork(); }

  // Стало
  // export async function POST(...) {
  //   const mapService = container.get('mapService'); // Вызывается при каждом запросе
  //   await mapService.doWork();
  // }
  ```
- **Ожидание:** Это гарантирует, что обработчик API всегда будет запрашивать у контейнера самый "свежий" экземпляр сервиса.
- **Результат:** Ошибки остались абсолютно теми же. Это самый неожиданный и нелогичный результат.

## 4. Финальная гипотеза

Проблема лежит в глубоком и неочевидном взаимодействии порядка загрузки модулей в Jest.

1.  Jest начинает выполнять тестовый файл (`.../route.test.js`).
2.  Он видит `import { POST } from './route'`.
3.  Он парсит `./route.js` и видит, что тот, в свою очередь, импортирует `import container from '@/lib/di-container'`.
4.  Jest создает и **кеширует** первоначальную, "сырую" версию DI-контейнера и всех сервисов. На этом этапе зависимости еще не внедрены правильно, потому что это просто анализ импортов.
5.  **Затем** Jest выполняет код теста и доходит до `beforeEach`.
6.  `jest.resetModules()` вызывается, но, по-видимому, он не может "отменить" уже частично разрешенные и закешированные зависимости для модуля `./route.js`, который был проанализирован в шаге 3.
7.  В итоге обработчик `POST` использует тот самый "сломанный" экземпляр из кеша (шаг 4), в то время как код самого теста использует "свежий" экземпляр (из `beforeEach`).

Это объясняет все симптомы, включая нелогичный провал последней попытки рефакторинга.

**Следующий шаг:** Необходимо найти способ заставить Jest полностью перестраивать граф зависимостей для тестируемого маршрута *после* вызова `jest.resetModules()`. Возможно, потребуется динамический `import()` внутри самого теста. 