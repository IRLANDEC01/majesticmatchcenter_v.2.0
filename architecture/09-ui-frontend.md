# UI и фронтенд MajesticMatchCenter

## 1. Подход к дизайну и UI

### 1.1 Единая система дизайна

MajesticMatchCenter использует централизованную систему дизайна, основанную на схеме #48 "Привлекательный и изящный". Все стили унифицированы и управляются из одного места, что обеспечивает согласованность интерфейса и упрощает разработку.

#### Основные принципы:
- **Единый источник правды**: все стили определены в `src/styles/globals.css` через CSS переменные
- **Автоматическое применение стилей**: компоненты автоматически наследуют правильные стили в зависимости от контекста
- **Контекстно-зависимая тема**: белый фон = темный текст, glassmorphism = белый текст
- **Переиспользуемые компоненты**: стандартизированный набор компонентов с единым стилем

#### Структура файлов дизайн-системы:
```
src/
├── styles/
│   └── globals.css               # Все CSS стили и переменные
└── components/ui/
    ├── mmc-design-system.jsx     # Компоненты React с единым стилем
    └── [базовые компоненты]      # Базовые UI компоненты
```

### 1.2 Цветовая палитра

Цвета определены через CSS переменные в HSL формате для совместимости с Shadcn UI:

```css
:root {
  /* Брендинговые цвета */
  --mmc-primary: 174 100% 29%;              /* #14A098 - основной teal */
  --mmc-secondary: 336 69% 52%;             /* #CB2D6F - magenta */
  
  /* Статусные цвета */
  --mmc-success: 158 64% 52%;               /* #10B981 - зеленый */
  --mmc-warning: 38 92% 50%;                /* #F59E0B - оранжевый */
  --mmc-danger: 0 84% 60%;                  /* #EF4444 - красный */
  --mmc-info: 221 83% 53%;                  /* #3B82F6 - синий */
  
  /* Нейтральные цвета */
  --mmc-white: 0 0% 100%;                   /* #FFFFFF */
  --mmc-black: 0 0% 0%;                     /* #000000 */
  --mmc-gray-[50-900]: [значения];          /* Оттенки серого */
}
```

### 1.3 Типографика

- **Основной шрифт**: Inter (sans-serif)
- **Моноширинный шрифт**: JetBrains Mono (для кода и технических данных)
- **Иерархия заголовков**: от H1 до H5 с соответствующими размерами и весами
- **Текстовые стили**: основной, вторичный, акцентный, с соответствующими цветами

### 1.4 Компоненты

Проект использует два типа компонентов:
1. **Базовые компоненты Shadcn UI**: кнопки, поля ввода, селекты и т.д.
2. **MMC компоненты**: обертки над базовыми компонентами с унифицированными стилями

```jsx
// Пример MMC компонентов
import { MMCCard, MMCButton, MMCInput } from '@/components/ui/mmc-design-system';

// Использование в коде
<MMCCard white>
  <MMCCardHeader>
    <MMCCardTitle>Заголовок</MMCCardTitle>
  </MMCCardHeader>
  <MMCCardContent>
    <MMCInput placeholder="Введите текст" />
    <MMCButton variant="primary">Сохранить</MMCButton>
  </MMCCardContent>
</MMCCard>
```

## 2. Рекомендуемый технологический стек фронтенда

### 2.1 Основные технологии

- **Next.js**: Фреймворк для React с серверными компонентами, обеспечивающий оптимальную производительность и SEO
- **React**: Библиотека для создания пользовательских интерфейсов с компонентным подходом
- **TailwindCSS**: Утилитарный CSS фреймворк для быстрой разработки интерфейсов без отрыва от HTML
- **shadcn/ui**: Компонентная библиотека на основе Radix UI с высокой доступностью и кастомизацией
- **React Hook Form**: Производительное управление формами с минимальными перерендерами
- **Zod**: Типобезопасная валидация данных с подробными сообщениями об ошибках
- **React Query**: Кэширование и управление состоянием данных с автоматической синхронизацией

### 2.2 Инструменты разработки

- **ESLint**: Статический анализ кода для выявления проблем и поддержания единого стиля
- **Prettier**: Автоматическое форматирование кода для консистентности
- **Husky + lint-staged**: Предкоммитные проверки кода для предотвращения проблем
- **Storybook**: Изолированная разработка и документирование компонентов
- **Jest + React Testing Library**: Тестирование компонентов с фокусом на пользовательский опыт
- **Playwright**: E2E тестирование для проверки работы приложения в реальных браузерах
- **Lighthouse CI**: Автоматический аудит производительности, доступности и SEO

### 2.3 Рекомендации по производительности

- **Core Web Vitals**: Оптимизация LCP, FID/INP и CLS для улучшения пользовательского опыта
- **Динамический импорт**: Разделение кода для ускорения начальной загрузки
- **Оптимизация изображений**: Использование next/image для автоматической оптимизации
- **Кэширование**: Стратегии кэширования данных на клиенте и сервере
- **Прогрессивная загрузка**: Скелетоны и плейсхолдеры для улучшения воспринимаемой скорости
- **Оптимизация шрифтов**: Предзагрузка и оптимизация FOIT/FOUT

## 3. Архитектура фронтенда

### 3.1 Модульная архитектура компонентов

Компоненты организованы по паттерну Container/View/Hook:

```
components/
├── admin/
│   └── MapForm_new/
│       ├── components/     # Презентационные компоненты
│       │   ├── MapFormBasicFields.jsx
│       │   ├── MapFormParticipants.jsx
│       │   └── MapFormStatistics.jsx
│       ├── hooks/          # Хуки с логикой
│       │   ├── useMapForm.js
│       │   └── useParticipants.js
│       ├── utils/          # Утилиты
│       │   └── mapFormHelpers.js
│       ├── MapFormContainer.jsx  # Контейнер с состоянием
│       └── MapFormView.jsx       # Презентационный компонент
```

#### Принципы организации:
- **Разделение ответственности**: контейнеры управляют состоянием, представления отвечают за рендеринг
- **Переиспользование логики**: бизнес-логика выделена в хуки
- **Изоляция компонентов**: каждый компонент имеет четкую ответственность
- **Группировка по функциональности**: связанные файлы находятся в одной директории

### 3.2 Рекомендуемая архитектура Next.js приложения

#### App Router и Server Components

Рекомендуется использовать App Router для новых проектов, который обеспечивает:

- **Серверные компоненты по умолчанию**: Снижение размера JavaScript бандла
- **Параллельные маршруты**: Независимая загрузка разных частей страницы
- **Интерцепторы маршрутов**: Модальные окна и оверлеи без изменения URL
- **Группы маршрутов**: Логическая организация маршрутов без влияния на URL
- **Streaming**: Постепенная отправка HTML с приоритизацией контента

#### Структура директорий

```
app/
├── (public)/                # Публичная часть сайта
│   ├── tournaments/         # Маршруты для турниров
│   │   ├── [slug]/          # Динамический маршрут турнира
│   │   │   ├── page.jsx     # Страница турнира
│   │   │   └── layout.jsx   # Макет страницы турнира
│   │   └── page.jsx         # Список турниров
│   ├── layout.jsx           # Основной макет публичной части
│   └── page.jsx             # Главная страница
├── admin/                   # Административная панель
│   ├── tournaments/         # Управление турнирами
│   ├── layout.jsx           # Макет админки с навигацией
│   └── page.jsx             # Дашборд админки
├── api/                     # API маршруты
│   └── [...]/               # Различные API эндпоинты
├── layout.jsx               # Корневой макет
└── page.jsx                 # Корневая страница (редирект)
```

### 3.3 Оптимальное использование Server и Client Components

#### Server Components (по умолчанию)
- **Данные**: Компоненты, которые получают данные с сервера
- **SEO**: Компоненты с метаданными и структурированными данными
- **Макеты**: Общие макеты страниц и секций
- **Статический контент**: Компоненты без интерактивности

#### Client Components ('use client')
- **Интерактивность**: Компоненты с обработчиками событий
- **Состояние**: Компоненты с локальным состоянием
- **Хуки**: Компоненты, использующие React хуки
- **Эффекты**: Компоненты с побочными эффектами

#### Пример оптимального разделения
```jsx
// Серверный компонент (page.jsx)
export default async function TournamentPage({ params }) {
  // Данные загружаются на сервере
  const tournament = await fetchTournament(params.slug);
  
  return (
    <div>
      <TournamentHeader tournament={tournament} />
      <TournamentDetails tournament={tournament} />
      {/* Клиентский компонент для интерактивных элементов */}
      <TournamentActions tournamentId={tournament.id} />
    </div>
  );
}

// Клиентский компонент (TournamentActions.jsx)
'use client';

export function TournamentActions({ tournamentId }) {
  const [isLoading, setIsLoading] = useState(false);
  
  const handleAction = async () => {
    setIsLoading(true);
    // Интерактивная логика
    setIsLoading(false);
  };
  
  return (
    <div>
      <button onClick={handleAction} disabled={isLoading}>
        {isLoading ? 'Загрузка...' : 'Действие'}
      </button>
    </div>
  );
}
```

### 3.4 Управление состоянием

Рекомендуется многоуровневый подход к управлению состоянием:

1. **Локальное состояние**: `useState` и `useReducer` для компонентного состояния
2. **Контекст**: `useContext` для состояния, разделяемого между компонентами
3. **Серверное состояние**: React Query для данных с сервера
4. **Глобальное состояние**: Zustand или Jotai для минимального глобального состояния

#### Пример использования React Query
```jsx
'use client';

import { useState } from 'react';
import { useQuery, useMutation, QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Провайдер в корневом клиентском компоненте
export function Providers({ children }) {
  const [queryClient] = useState(() => new QueryClient());
  
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}

// Использование в компоненте
export function TournamentsList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['tournaments'],
    queryFn: () => fetch('/api/tournaments').then(res => res.json())
  });
  
  if (isLoading) return <Skeleton />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <ul>
      {data.map(tournament => (
        <li key={tournament.id}>{tournament.name}</li>
      ))}
    </ul>
  );
}
```

### 3.5 Формы и валидация

Для работы с формами рекомендуется комбинация React Hook Form и Zod:

```jsx
// Пример формы с валидацией
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

// Схема валидации
const schema = z.object({
  name: z.string().min(3, "Имя должно содержать минимум 3 символа"),
  email: z.string().email("Некорректный email адрес")
});

export function UserForm() {
  const form = useForm({
    resolver: zodResolver(schema),
    defaultValues: {
      name: '',
      email: ''
    }
  });
  
  const onSubmit = async (data) => {
    // Отправка данных на сервер
    await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="name">Имя</label>
        <input id="name" {...form.register('name')} />
        {form.formState.errors.name && (
          <span>{form.formState.errors.name.message}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="email" {...form.register('email')} />
        {form.formState.errors.email && (
          <span>{form.formState.errors.email.message}</span>
        )}
      </div>
      
      <button type="submit" disabled={form.formState.isSubmitting}>
        {form.formState.isSubmitting ? 'Отправка...' : 'Отправить'}
      </button>
    </form>
  );
}
```

## 4. Лучшие практики разработки UI

### 4.1 Atomic Design

Компоненты организованы по методологии Atomic Design:

1. **Атомы**: базовые компоненты (кнопки, поля ввода, иконки)
2. **Молекулы**: комбинации атомов (формы поиска, карточки игроков)
3. **Организмы**: сложные компоненты (формы, таблицы статистики)
4. **Шаблоны**: макеты страниц без конкретного контента
5. **Страницы**: конкретные реализации шаблонов с данными

### 4.2 Responsive Design

Интерфейс адаптируется к различным размерам экрана:

- **Mobile-first**: базовые стили для мобильных устройств
- **Breakpoints**: медиа-запросы для адаптации к различным устройствам
- **Fluid typography**: масштабируемая типографика
- **Grid system**: гибкая система сеток для разметки

```css
/* Пример адаптивных стилей */
.mmc-form-wide {
  width: 100%;
  max-width: var(--mmc-size-form-wide);
}

@media (max-width: 48rem) { /* --mmc-breakpoint-tablet */
  .mmc-form-wide {
    max-width: 100%;
    padding: 0 1rem;
  }
}
```

### 4.3 Доступность (A11y)

Проект должен следовать принципам доступности:

- **Семантическая разметка**: правильное использование HTML тегов
- **ARIA атрибуты**: для улучшения доступности сложных компонентов
- **Клавиатурная навигация**: все интерактивные элементы доступны с клавиатуры
- **Контрастные цвета**: соответствие требованиям WCAG
- **Альтернативный текст**: для изображений и иконок
- **Фокусные состояния**: видимые индикаторы фокуса
- **Скринридеры**: тестирование с NVDA или VoiceOver

### 4.4 Интернационализация (i18n)

Подготовка к многоязычности:

- **Отделение текстов**: все строки выделены в отдельные файлы
- **next-intl**: библиотека для интернационализации
- **Форматирование дат и чисел**: с учетом локали
- **Направление текста**: поддержка RTL языков
- **Плюрализация**: корректное склонение слов в зависимости от числа

## 5. Безопасность фронтенда

### 5.1 Защита от XSS

- **Content-Security-Policy**: Ограничение источников контента
- **Экранирование данных**: Автоматическое экранирование в JSX
- **DOMPurify**: Очистка HTML при необходимости отображения пользовательского контента
- **Строгие типы данных**: Валидация всех входных данных

### 5.2 Защита от CSRF

- **SameSite cookies**: Установка атрибута SameSite=Strict или Lax
- **CSRF токены**: Использование токенов для мутирующих операций
- **Origin/Referer проверки**: Валидация источника запроса

### 5.3 Защита данных пользователя

- **Минимизация данных**: Сбор только необходимых данных
- **Шифрование**: Использование HTTPS для всех запросов
- **Хранение токенов**: Безопасное хранение в httpOnly cookies
- **Автоматический выход**: Истечение сессии при неактивности

### 5.4 Аудит зависимостей

- **npm audit**: Регулярная проверка зависимостей
- **Dependabot**: Автоматическое обновление уязвимых пакетов
- **Snyk**: Мониторинг уязвимостей в реальном времени

## 6. Оптимизация производительности

### 6.1 Метрики производительности

- **Core Web Vitals**:
  - LCP (Largest Contentful Paint): < 2.5с
  - FID (First Input Delay) / INP (Interaction to Next Paint): < 100мс
  - CLS (Cumulative Layout Shift): < 0.1

- **Дополнительные метрики**:
  - TTFB (Time to First Byte): < 600мс
  - FCP (First Contentful Paint): < 1.8с
  - TTI (Time to Interactive): < 3.8с

### 6.2 Стратегии оптимизации

- **Серверные компоненты**: Уменьшение размера JS бандла
- **Streaming**: Постепенная загрузка контента
- **Прогрессивная гидратация**: Приоритизация интерактивных элементов
- **Предзагрузка ресурсов**: Использование `<link rel="preload">`
- **Оптимизация изображений**: Форматы WebP/AVIF, правильные размеры
- **Ленивая загрузка**: Отложенная загрузка контента за пределами вьюпорта
- **Кэширование**: Эффективное использование браузерного и серверного кэша

### 6.3 Мониторинг производительности

- **Lighthouse**: Аудит производительности в процессе разработки
- **Web Vitals**: Мониторинг метрик в реальном использовании
- **Performance API**: Сбор пользовательских метрик
- **RUM (Real User Monitoring)**: Анализ производительности у реальных пользователей

## 7. Тестирование фронтенда

### 7.1 Уровни тестирования

- **Модульные тесты**: Тестирование отдельных компонентов и функций
- **Интеграционные тесты**: Тестирование взаимодействия между компонентами
- **E2E тесты**: Тестирование полных пользовательских сценариев

### 7.2 Инструменты тестирования

- **Jest**: Фреймворк для модульного тестирования
- **React Testing Library**: Тестирование компонентов с фокусом на пользовательский опыт
- **Playwright**: E2E тестирование в реальных браузерах
- **Mock Service Worker**: Мокирование API запросов
- **Storybook**: Визуальное тестирование компонентов

### 7.3 Стратегия тестирования

- **Тестовая пирамида**: Больше модульных тестов, меньше E2E
- **Критические пути**: Приоритет тестирования основных пользовательских сценариев
- **Регрессионное тестирование**: Автоматизированные тесты для предотвращения регрессий
- **Снапшот-тестирование**: Для отслеживания изменений в UI компонентах

## 8. Рекомендации по разработке

### 8.1 Стандарты кодирования

- **Единый стиль кода**: следование ESLint и Prettier конфигурации
- **Именование компонентов**: PascalCase для компонентов, camelCase для функций
- **Организация импортов**: группировка импортов (React, библиотеки, компоненты, стили)
- **Комментарии**: JSDoc для публичных API, обычные комментарии для сложной логики

### 8.2 Code review чеклист

- **Функциональность**: Работает ли код как ожидается
- **Производительность**: Нет ли лишних ререндеров или утечек памяти
- **Доступность**: Соответствует ли код стандартам доступности
- **Безопасность**: Нет ли потенциальных уязвимостей
- **Тестируемость**: Покрыт ли код тестами
- **Поддерживаемость**: Понятен ли код и соответствует ли стандартам
- **Повторное использование**: Можно ли выделить переиспользуемые части

### 8.3 Рабочий процесс

1. **Создание компонента**: начинать с базовой функциональности
2. **Стилизация**: применение стилей из дизайн-системы
3. **Добавление интерактивности**: обработчики событий, состояние
4. **Тестирование**: unit-тесты и интеграционные тесты
5. **Документация**: комментарии и примеры использования
6. **Ревью кода**: проверка соответствия стандартам

### 8.4 Использование дизайн-системы

- **Предпочтение MMC компонентов**: использовать MMC компоненты вместо базовых
- **Соблюдение цветовой схемы**: использовать только цвета из палитры
- **Консистентность отступов**: использовать переменные для отступов
- **Переиспользование**: избегать дублирования стилей

## 9. Ресурсы и документация

- **Единая система дизайна**: `docs/unified-design-system-guide.md`
- **Централизованная система дизайна**: `docs/mmc-centralized-design-system.md`
- **UI Kit**: `design-templates/components/ui-kit.html`
- **Примеры компонентов**: `src/components/ui/`
- **CSS переменные**: `src/styles/globals.css` 
- **Next.js документация**: https://nextjs.org/docs
- **React документация**: https://react.dev/
- **Shadcn UI**: https://ui.shadcn.com/
- **TailwindCSS**: https://tailwindcss.com/docs
- **React Hook Form**: https://react-hook-form.com/
- **Zod**: https://zod.dev/
- **React Query**: https://tanstack.com/query/latest

# План и архитектура фронтенда и UI (2024)

---

## 0. Общие принципы

- **Технологии:** Next.js 15 (App Router), React 19, TailwindCSS, shadcn/ui, JavaScript ES2022 (без TypeScript).
- **Архитектура:** Слоистая (UI → API → Domain → Infra), гексагональная, DDD.
- **Паттерны:** Atomic Design, Container/View/Hook, Islands Architecture.
- **UI:** Адаптивный дизайн (без mobile-first), боковая навигация для админки, переиспользуемые компоненты.
- **Тесты:** Jest + Testing Library (unit/integration), Playwright (e2e, по мере необходимости).

---

## 1. Структура проекта (frontend)

```
src/
├── app/                # Next.js маршруты (публичные и админка)
│   ├── admin/          # Админка (разделы по доменным сущностям)
│   ├── players/        # Публичные страницы игроков (заглушки)
│   ├── families/       # Публичные страницы семей (заглушки)
│   ├── tournaments/    # Публичные страницы турниров (заглушки)
│   ├── maps/           # Публичные страницы карт (заглушки)
│   └── ...             # Другие публичные страницы
├── components/
│   ├── ui/             # Атомарные и молекулярные компоненты (Button, Input, Modal и т.д.)
│   ├── layout/         # Layout-компоненты (Sidebar, Header, PageContainer)
│   ├── forms/          # Формы для создания/редактирования сущностей
│   └── admin/          # Доменные компоненты админки (таблицы, карточки, фильтры)
├── lib/
│   ├── api/            # Хуки и функции для работы с API (fetch, react-query)
│   ├── hooks/          # Общие хуки (например, useAuth, useRole, useModal)
│   └── utils/          # Вспомогательные функции (валидация, форматирование)
├── styles/             # Глобальные стили (globals.css), кастомные Tailwind-стили
├── public/             # Статические файлы (логотипы, иконки, изображения)
└── tests/              # Тесты компонентов и e2e (по мере необходимости)
```

---

## 2. Базовые этапы работы

### 2.1. Инициализация и настройка

- Установить Next.js, TailwindCSS, shadcn/ui, react-query, react-hook-form, zod.
- Настроить tailwind.config.js (цвета, шрифты, брейкпоинты — позже подберем палитру).
- Настроить глобальные стили (reset, базовые переменные).
- Настроить структуру папок (см. выше).

### 2.2. Базовые UI-компоненты

- Создать атомарные компоненты: Button, Input, Select, Modal, Table, Loader, Avatar, FileUpload.
- Создать layout-компоненты: Sidebar (боковая навигация), Header, PageContainer.
- Настроить базовую страницу админки с боковой навигацией и заглушками для разделов.

### 2.3. Авторизация и роли

- Интегрировать NextAuth.js с Яндекс ID (начать с моков, если нет ключей).
- Реализовать useAuth/useRole хуки для проверки прав пользователя.
- Ограничить доступ к админке по ролям (RBAC).
- Скрывать/отключать UI-элементы в зависимости от роли.

### 2.4. CRUD-страницы для админки

- Для каждой доменной сущности (Игрок, Семья, Турнир, Карта, Новость, Шаблон):
  - Таблица с фильтрами и пагинацией (react-query).
  - Форма создания/редактирования (react-hook-form + zod).
  - Компоненты для просмотра и удаления.
  - Загрузка изображений (аватар, логотип, баннер) через FileUpload.
- Реализовать универсальный шаблон для CRUD-страниц (легко масштабировать под новые сущности).

### 2.5. API-слой

- Вынести все запросы к API в отдельные хуки (usePlayers, useFamilies, useTournaments и т.д.).
- Использовать react-query для кэширования и управления состоянием загрузки/ошибок.
- Реализовать обработку ошибок (единый обработчик, всплывающие уведомления).

### 2.6. Публичные страницы (заглушки)

- Создать базовые роуты и страницы для публичных разделов (players, families, tournaments, maps).
- Пока просто выводить "В разработке" или пустой список.
- Позже — наполнить данными и реализовать аналитику/статистику.

### 2.7. Тестирование

- Unit-тесты для атомарных компонентов (Button, Input, Modal и т.д.).
- Интеграционные тесты для форм (валидация, отправка, обработка ошибок).
- E2E-тесты для основных сценариев админки (логин, создание сущности, навигация) — по мере необходимости.

### 2.8. Темизация и кастомизация

- После выбора палитры — настроить цвета и шрифты в tailwind.config.js.
- Кастомизировать shadcn/ui под ваш стиль.
- Заложить поддержку светлой/темной темы (если потребуется в будущем).

---

## 3. Организация переиспользуемых компонентов

- Все атомарные компоненты (кнопки, инпуты, аватары) — в `components/ui/`.
- Layout-компоненты (Sidebar, Header, PageContainer) — в `components/layout/`.
- Формы и их элементы — в `components/forms/`.
- Доменные компоненты (таблицы, карточки, фильтры для админки) — в `components/admin/`.
- Все стили — через Tailwind, кастомизация через tailwind.config.js.
- Глобальные переменные (цвета, шрифты) — только через Tailwind.

---

## 4. Интеграция с бэкендом

- Все CRUD-операции — через API-эндпоинты, уже реализованные на бэке.
- Для форм — использовать те же схемы валидации (zod), что и на бэке (по возможности).
- Для загрузки файлов — интеграция с S3-совместимым хранилищем (через API).
- Для авторизации — NextAuth.js с Яндекс ID, хранение сессий через Redis (как в инфраструктуре).

---

## 5. Роли и права (RBAC)

- Супер-админ: полный доступ ко всем сущностям и настройкам.
- Админ: доступ к основным CRUD-операциям, но без критических настроек.
- Модератор: ограниченный доступ (например, только просмотр и редактирование отдельных сущностей).
- Все проверки прав — как на фронте (скрытие/отключение UI), так и на бэке (API).

---

## 6. Дальнейшее развитие

- После наполнения админки — постепенное развитие публичных страниц (статистика, аналитика, рейтинги).
- Добавление графиков и визуализации (recharts, chart.js, nivo) — по мере необходимости.
- Внедрение CI/CD для фронта — когда появится потребность в автоматизации.
- Оптимизация производительности и доступности — по мере роста проекта.

---

## 7. Документирование и поддержка

- Документировать все компоненты и хуки (JSDoc, комментарии на русском).
- Вести краткие описания архитектурных решений в memory-bank и архитектурной документации.
- Все важные изменения фиксировать в memory-bank и .cursor/rules/memory-bank.mdc.

---

## 8. Пример первого этапа (MVP для админки)

1. Настроить базовую структуру проекта и Tailwind.
2. Реализовать Sidebar, Header, PageContainer.
3. Сделать заглушки для всех разделов админки.
4. Реализовать CRUD для одной сущности (например, Игроки) с загрузкой аватара.
5. Интегрировать авторизацию через Яндекс ID (или мок).
6. Покрыть базовые компоненты тестами.
7. После этого — масштабировать на остальные сущности.

---

## 9. Как дополнять и редактировать план

- После каждого этапа — фиксировать прогресс и корректировать план.
- При появлении новых требований — дополнять архитектуру и структуру.
- Все изменения и новые решения — документировать в memory-bank. 