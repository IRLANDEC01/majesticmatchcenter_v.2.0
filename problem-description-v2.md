# Описание Проблемы: Нестабильные тесты после рефакторинга на DI-контейнер

## 1. Контекст и Цель

Мы провели масштабный рефакторинг системы учета статистики и рейтингов. Исходная архитектура с разрозненными моделями (`PlayerRatingHistory`) была заменена на более целостную (`PlayerMapParticipation`). В ходе этого процесса для управления зависимостями между сервисами (`MapService`, `RatingService`, `StatisticsService`) был внедрен простой DI-контейнер (`src/lib/di-container.js`).

**Цель рефакторинга:** Добиться, чтобы все интеграционные тесты (`*.test.js`) проходили успешно, подтверждая корректность новой архитектуры.

## 2. Проблема: Стойкая Ошибка `TypeError` в тестах

Несмотря на все исправления, две группы тестов стабильно падают:
- `src/app/api/admin/maps/[id]/complete/route.test.js`
- `src/app/api/admin/maps/[id]/rollback/route.test.js`

Оба теста падают с одной и той же по сути ошибкой:
```
TypeError: Cannot read properties of undefined (reading 'upsert')
```
или
```
TypeError: Cannot read properties of undefined (reading 'findAndDeleteByMapId')
```
Ошибка возникает внутри `RatingService`, который вызывается из `MapService`. Это однозначно указывает на то, что в момент вызова, свойства `this.playerMapParticipationRepo` или `this.familyMapParticipationRepo` в инстансе `RatingService` равны `undefined`.

**Это происходит вопреки тому, что:**
1.  DI-контейнер (`di-container.js`) явно создает `RatingService` и передает ему в конструктор все необходимые репозитории.
2.  API-маршруты (`.../route.js`) и файлы тестов (`.../route.test.js`) получают инстанс `MapService` (который содержит `RatingService`) из этого же контейнера.
3.  Из `RatingService` были удалены все "старые" прямые импорты репозиториев, чтобы исключить конфликты.

## 3. Что уже было сделано (хронология попыток)

1.  **Первоначальная ошибка:** После рефакторинга сервисов и схем тесты упали с `TypeError`.
2.  **Попытка 1 (DI-хак):** В `map-service.js` были вручную "до-внедрены" зависимости в импортированный синглтон `ratingService`. **Результат:** Неудача. Jest, вероятно, кэшировал модули, и другие части системы получали "старый" инстанс сервиса.
3.  **Попытка 2 (DI-контейнер):** Был создан `src/lib/di-container.js`. Все сервисы были переписаны для получения зависимостей через конструктор. Все API-маршруты для карт были переписаны для получения `mapService` из контейнера. **Результат:** Ошибки сохранились.
4.  **Попытка 3 (Исправление импортов):** Были обнаружены и исправлены неверные пути импорта (`PlayerNotFoundError`). **Результат:** Ошибки сохранились.
5.  **Попытка 4 (Восстановление Zod схем):** В `map-service.js` были восстановлены случайно удаленные Zod-схемы для валидации. **Результат:** Ошибки сохранились.
6.  **Попытка 5 (Удаление старых импортов):** Были обнаружены и удалены конфликтующие прямые импорты репозиториев из `rating-service.js`. **Результат:** Ошибки **все равно сохранились**.

## 4. Ключевые файлы для анализа

- **Контейнер:** `src/lib/di-container.js`
- **Проблемный сервис:** `src/lib/domain/ratings/rating-service.js`
- **Сервис-потребитель:** `src/lib/domain/maps/map-service.js`
- **Падающий тест:** `src/app/api/admin/maps/[id]/rollback/route.test.js`
- **Падающий маршрут:** `src/app/api/admin/maps/[id]/rollback/route.js`

## 5. Гипотеза: Аномалия в работе Jest

Логика DI-контейнера выглядит корректной. Код самих сервисов и маршрутов выглядит корректным. Поскольку ошибка возникает **только при запуске тестов Jest**, наиболее вероятная причина — это аномалия в том, как Jest разрешает, кэширует или исполняет модули в нашем конкретном случае.

Возможно, инстанс `RatingService`, который используется в тестах, по какой-то причине создается **до того**, как DI-контейнер успевает ему присвоить репозитории, или же Jest использует какую-то закэшированную, "пустую" версию сервиса.

## 6. Запрос к следующему AI-ассистенту

Пожалуйста, помоги решить эту проблему. Прошу:
1.  Не предлагать снова решения, которые уже были опробованы выше (особенно связанные с импортами и созданием DI).
2.  Сфокусироваться на взаимодействии **Jest** и нашего **DI-контейнера**.
3.  Рассмотреть возможность использования **фабрик или моков на уровне Jest** (`jest.mock`), чтобы принудительно подменять реализацию `mapService` в тестах на заведомо рабочий инстанс из контейнера. Возможно, нужно очищать кэш модулей (`jest.resetModules()`) перед каждым тестом, который использует наш контейнер.

Спасибо! 